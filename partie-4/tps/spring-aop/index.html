<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1">
    <title>Spring AOP</title>

    <link href="../../../common/css/css.css" rel="stylesheet" type="text/css">
    <link href="../../../common/css/prettify.css" rel="stylesheet" id="prettify-link">
    <link href="../../../common/css/default.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/dev.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/project.css" class="theme" rel="stylesheet">

    <script src="../../../common/js/prettify.js" onload="prettyPrint();"></script>
    <script src="../../../common/js/main.js" type="text/javascript"></script>
</head>
<body>
<div class="presentation">
    <div id="project">
        <h1><img src="img/spring.png" alt="" style="margin-right:5px;height:40px;position: relative;top:6px;">Spring AOP</h1>

        <h2>Introduction</h2>

        <p>La programmation orientée aspect (AOP) est une technique qui vise à isoler certains comportements afin de rendre l'application plus modulaire.</p>

        <p>Les aspects qui peuvent être extrait d'une application sont souvent dit orthogonaux à celle-ci : ils peuvent évoluer indépendamment du but premier de l'application.</p>

        <h2>Un exemple simple</h2>

        <p>L'exemple canonique de l'AOP est le logging.</p>

        <p>Admettons que nous souhaitions logger toutes les entrées et sorties des méthodes dans nos services.</p>

        <pre>public void doSomething() {
   log.trace("Entering in doSomething()");

   <span class="comment">...</span>

   log.trace("Leaving doSomething()");
}</pre>

        <p>Si l'on doit faire cela sur plusieurs centaines de méthodes, c'est assez peu efficace.</p>

        <p>De plus, il n'y a pas de mécanisme classique en programmation objet qui éviterait la duplication de code.</p>

        <p>L'AOP prend donc le problème à l'envers : on isole le comportement de logging dans un composant et on l'applique sur tous nos services.</p>

        <pre>public void around(Method method) {
   log.trace("Entering in doSomething()");

   method.call();

   log.trace("Leaving doSomething()");
}</pre>

        <p>Il reste donc a savoir comment on définit un aspect et comment on l'applique sur d'autres composants.</p>

        <h2>Aspectj</h2>

        <p>Avec spring, nous allons utiliser aspectj, qui est la librairie de référence pour l'AOP en java.</p>

        <p>En java, il existe 3 façons d'injecter les aspects (weaving) dans le code : à la compilation (compile time), au chargement des classes (load time) ou pendant l'exécution (runtime)</p>

        <p>Nous allons le faire au runtime, c'est plus limité mais plus simple à mettre en place.</p>

        <p>La détection d'aspects est activée avec la configuration spring suivante.</p>

        <pre><span class="comment">&lt;!-- Support d'aspectj --&gt;</span>
&lt;aop:aspectj-autoproxy/&gt;</pre>

        <p>Il faut aussi ajouter la librairie spring-aop</p>

        <pre>&lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
   &lt;version&gt;3.0.5.RELEASE&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>

        <p>Et aspectj</p>

        <pre>&lt;dependency&gt;
   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
   &lt;version&gt;1.6.12&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
   &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
   &lt;version&gt;1.6.12&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>

        <p>Et cglib (librairie de manipulation de byte code)</p>

        <pre>&lt;dependency&gt;
   &lt;groupId&gt;cglib&lt;/groupId&gt;
   &lt;artifactId&gt;cglib&lt;/artifactId&gt;
   &lt;version&gt;2.2.2&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>

        <h2>Un aspect simple</h2>

        <p>Nous créons le package edu.ecm.blog.aop et on l'ajoute au component scan</p>

        <pre>&lt;context:component-scan base-package="edu.ecm.blog.aop"/&gt;</pre>

        <p>Voici un aspect qui affiche le temps d'exécution de chaque méthode.</p>

        <pre>
@Aspect
@Component
public class TraceAspect {
   @Around("within(edu.ecm.blog..*)")
   public Object trace(ProceedingJoinPoint pjp) throws Throwable {
      long t1 = System.currentTimeMillis();

      <b>Object value = pjp.proceed()</b>;

      long t2 = System.currentTimeMillis();

      System.out.println("Executed " + pjp.getSignature() + " in " + (t2 - t1) + "ms");

      return value;
   }
}</pre>

        <p>@Aspect indique que le composant est un aspect.</p>

        <p>@Around indique que notre aspect doit s'exécuter autour de le méthode.</p>

        <p>ProceedingJoinPoint est un objet qui décrit l'appel en cours.</p>

        <p>Avec cette aspect en place, on obtient le log suivant lors de l'appel de http://localhost:8080/index.</p>

        <pre>Executed List edu.ecm.blog.service.PostService.find(int,int) in 51ms
Executed String edu.ecm.blog.web.controller.BlogController.index(Model) in 66ms</pre>

        <p>En modifiant la règle de matching, on peut atteindre du code des librairies</p>

        <pre>@Around("within(org.hibernate..*)")</pre>

        <p>Donne</p>

        <pre>Executed Session org.hibernate.SessionFactory.openSession() in 0ms
Executed Session org.hibernate.SessionFactory.getCurrentSession() in 1ms</pre>

        <h2>Mécanique runtime</h2>

        <p>Pour rendre possible l'AOP au runtime, spring utilise une technique simple : il intercale un proxy entre l'appelant et la cible.</p>

        <img src="img/aspect-proxy.png" alt="" style="margin: 0 200px;">

        <p>Au runtime, il n'est donc possible de faire de l'aop qui si il y a un appel de méthode.</p>

        <p>En conséquence, seule les méthodes publiques peuvent être concernées.</p>

        <p>C'est généralement suffisant. Pour plus de possibilités, il faut se tourner vers le weaving au moment de la compilation.</p>

        <p>Pour faire un proxy java, il existe 2 méthodes :</p>

        <ul>
            <li>La mécanique java standard : il faut que la classe cible impléménte une interface</li>
            <li>La manipulation de bytecode (comme cglib) : peut s'appliquer à toutes les classes</li>
        </ul>

        <h2>@Transactional</h2>

        <p>Avec spring, rendre une méthode transactionnelle est aussi simple que qu'annoter une méthode.</p>

        <p>La technique utilisée est la même : spring ajoute un proxy qui va suivre la transaction.</p>

        <p>La prise en compte de @Transactional ne nécessite ni aspectj ni cglib.</p>

        <p>Spring utilise la mécanique standard java qui permet de faire un proxy à partir d'une interface.</p>

        <ul>
            <li>Le service annoté doit donc hériter ses methodes d'une interface.</li>
            <li>Seules les méthodes de l'interface (publiques par nature) peuvent être annotées.</li>
        </ul>

        <p>Spring a donc nativement des capacités d'AOP mais elle sont limitées.</p>

        <h2>Lexique</h2>

        <p>Les termes liés à l'AOP sont complexes, difficiles à retenir mais leur utilisation est classique.</p>

        <ul>
            <li>Aspect : un module contenant le code qui pourra être injecté</li>
            <li>Cross cutting : Découpage de d'éléments réutilisables orthogonaux à l'application</li>
            <li>join point : un point d'exécution de l'application pendant lequel un aspect peut être injecté</li>
            <li>Advice : type d'injection pour un point d'exécution. Par exemple : around, before, after, exception...</li>
            <li>Pointcut : un prédicat qui permet de désigner des join points.</li>
            <li>Target object : l'objet qui va être altéré pas l'injection d'aspects.</li>
            <li>AOP proxy : objet injecter entre l'appelant et la cible afin d'implémenter la mécanique AOP.</li>
            <li>Weaving : action d'injecter les aspects en respectant les pointcuts et advices.</li>
        </ul>

        <p>En pratique, la connaissance des termes n'est pas un pré requis à faire de l'AOP.</p>

        <h2>Aspects et annotations</h2>

        <p>Les aspects n'ont pas de rapport direct avec les annotations.</p>

        <p>Cependant, il est possible d'utiliser les annotations comme prédicats (pointcut).</p>

        <p>L'association des aspects et des annotations permet donc d'ajouter un comportement transverse pas simple annotations</p>

        <p>Les aspects pouvant eux être disponibles dans une librairie.</p>

        <h2>Un peu de cache</h2>

        <p>La problématique de cache est un élément d'une application facile à impléménter via AOP.</p>

        <p>Nous allons ajouter les mécaniques suivantes :</p>

        <ul>
            <li>Ajouter un cache aux méthodes find, findById, findBySlug et count du PostService.</li>
            <li>Lorsque que les méthodes save et delete sont appelées, le cache doit être vidé (flush).</li>
        </ul>

        <p>Nous allons utiliser ehcache comme librairie de cache.</p>

        <pre>&lt;dependency&gt;
   &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
   &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt;
   &lt;version&gt;2.4.6&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>

        <p>Son utilisation est simple. Pour des cas plus complexes, elle est même capable de devenir distribuée au travers de <a href="http://www.terracotta.org/" target="_blank" class="external">terracotta</a></p>

        <p>La configuration spring</p>

        <pre>&lt;bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"&gt;
   &lt;property name="configLocation" value="/WEB-INF/ehcache.xml" /&gt;
&lt;/bean&gt;

&lt;bean id="postsCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt;
   &lt;property name="cacheManager" ref="cacheManager" /&gt;
   &lt;property name="cacheName" value="postsCache" /&gt;
&lt;/bean&gt;</pre>

        <p>Et le fichier WEB-INF/ehcache.xml associé</p>

        <pre>&lt;ehcache&gt;
   &lt;defaultCache maxElementsInMemory="500" eternal="true" overflowToDisk="false"
            memoryStoreEvictionPolicy="LFU"/&gt;
   &lt;cache name="postsCache" maxElementsInMemory="500" eternal="true" overflowToDisk="false"
            memoryStoreEvictionPolicy="LRU"/&gt;
&lt;/ehcache&gt;</pre>

        <p>Nous avons donc maintenant un cache postsCache disponible.</p>

        <p>Nous définissons 2 annotations dans le package edu.ecm.blog.annotation</p>

        <pre>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface UseCache {
}</pre>

        <pre>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface FlushCache {
}</pre>

        <p>Elles nous servent a annoter les méthodes du PostServiceImpl</p>

        <pre>@UseCache
public Post findById(Long id) {
   <span class="comment">...</span>
}</pre>

        <p>Il nous alors définir notre Aspect.</p>

        <pre>@Aspect
@Component
public class CacheAspect {
   @Inject
   private Ehcache postsCache;

   @Around("@annotation(useCache)")
   public Object cache(ProceedingJoinPoint pjp, UseCache useCache) throws Throwable {
       return pjp.proceed();
   }

   @Around("@annotation(flushCache)")
   public Object flush(ProceedingJoinPoint pjp, FlushCache flushCache) throws Throwable {
       return pjp.proceed();
   }
}</pre>

        <p>Proposer une implémentation pour ces 2 méthodes.</p>

        <h2>Oui mais...</h2>

        <p>Ce que nous avons mis en place est simple et peut évoluer facilement.</p>

        <p>Mais depuis peu, spring propose une <a href="http://static.springsource.org/spring/docs/3.1.0.M1/spring-framework-reference/html/cache.html" target="_blank" class="external">abstraction pour le cache</a></p>

        <p>Elle propose ce que nous venons d'implémenter en beaucoup plus souple.</p>
    </div>
</div>
</body>
</html>