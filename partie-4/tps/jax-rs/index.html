<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1">
    <title>Java API for RESTful Web Services</title>

    <link href="../../../common/css/css.css" rel="stylesheet" type="text/css">
    <link href="../../../common/css/prettify.css" rel="stylesheet" id="prettify-link">
    <link href="../../../common/css/default.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/dev.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/project.css" class="theme" rel="stylesheet">

    <script src="../../../common/js/prettify.js" onload="prettyPrint();"></script>

</head>
<body>
<div class="presentation">
    <div id="project">
        <h1>Java API for RESTful Web Services</h1>

        <h2>Introduction</h2>

        <p>Les services REST ont longtemps peiné a trouver une définition aboutie permettant de bâtir une spécification.</p>

        <p>Aujourd'hui, ils sont en pleine expansion, prenant parfois la place des services soap.</p>

        <p>Cependant, l'approche est radicalement différente des services web :</p>

        <ul>
            <li>Les services REST sont orientés ressource (et non du rpc)</li>
            <li>Ils utilisent exclusivement le protocole HTTP</li>
            <li>Seule la partie coté serveur est couverte par la spécification</li>
        </ul>

        <p>En pratique, ils sont plus simples à mettre en place</p>

        <h2>Jersey</h2>

        <p><a href="http://jersey.java.net/" class="external" target="_blank">Jersey</a> est l'implémentation standard java pour les services REST.</p>

        <p>Coté serveur, il suffit d'annoter les méthodes avec quelques annotations :</p>

        <ul>
            <li>@Path : le chemin de la ressource (ex : /rest/posts)</li>
            <li>@GET, @PUT, @POST, @DELETE : les actions de l'interface uniforme</li>
            <li>@Consumes : routage en fonction du type mime de la requête</li>
            <li>@Produces : type de données de la réponse</li>
        </ul>

        <p>Il existe d'autres framework comme <a href="http://www.jboss.org/resteasy" class="external" target="_blank">Resteasy</a> et <a href="http://www.restlet.org/" class="external" target="_blank">restlet</a>.</p>

        <p>Il est même possible de faire du REST en spring MVC.</p>

        <p>Nous allons partir avec Jersey</p>

        <pre>&lt;dependency&gt;
    &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-server&lt;/artifactId&gt;
    &lt;version&gt;1.11&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-servlet&lt;/artifactId&gt;
    &lt;version&gt;1.11&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-grizzly2&lt;/artifactId&gt;
    &lt;version&gt;1.11&lt;/version&gt;
&lt;/dependency&gt;</pre>

        <h2>Hello world</h2>

        <p>Nous allons construire un service factice qui dit bonjour.</p>

        <p>La première classe à mettre en place est la ressource, dans le package edu.ecm.blog.rest.</p>

        <pre>@Path("/hi/{username}")
public class HelloWorldResource {
   @GET
   @Produces(MediaType.TEXT_PLAIN)
   public String hi(@PathParam("username") String username) {
       return "Hello " + StringUtils.defaultIfEmpty(username, "unknown");
   }
}</pre>

        <p>Ensuite, il faut déclarer une application REST dans le même package.</p>

        <pre>public class BlogApplication extends PackagesResourceConfig {
   public BlogApplication() {
       super("edu.ecm.blog.rest");
   }
}</pre>

        <p>Cette application enregistre toutes les ressources de notre service en faisant un scan de package.</p>

        <p>Le dernier point est la déclaration de l'application REST dans le web.xml</p>

        <pre>&lt;servlet&gt;
   &lt;servlet-name&gt;rest&lt;/servlet-name&gt;
   &lt;servlet-class&gt;com.sun.jersey.spi.container.servlet.ServletContainer&lt;/servlet-class&gt;
   &lt;init-param&gt;
      &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;
      &lt;param-value&gt;<b>edu.ecm.blog.rest.BlogApplication</b>&lt;/param-value&gt;
   &lt;/init-param&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;rest&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre>

        <p>Avec le serveur tomcat démarré, le service répond sur http://localhost:8080/rest/hi/you</p>

        <h3>Le client</h3>

        <p>Nous allons mettre en place un test d'intégration qui va valider le bon fonctionnement de notre service.</p>

        <p>Afin que jenkins n'éxécute pas ces tests avec les tests unitaires, nous pouvons :</p>

        <ul>
            <li>Placer ces tests dans un package edu.ecm.blog.integration</li>
            <li>Exclure ce package lors des tests unitaires
                <pre>&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;excludes&gt;
            &lt;exclude&gt;**/integration/*Test.java&lt;/exclude&gt;
        &lt;/excludes&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</pre>
            </li>
        </ul>

        <p>On crée donc la classe HelloWorldResourceTest dans le package edu.ecm.blog.integration de src/test/java.</p>

        <p>Il n'y a pas de génération de client comme pour les services web mais juste un jar.</p>

        <pre>&lt;dependency&gt;
   &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;
   &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;
   &lt;version&gt;1.11&lt;/version&gt;
&lt;/dependency&gt;</pre>

        <p>Après quoi on peut écrire.</p>

        <pre>@Test
public void hi() {
    Client client = Client.create();
    WebResource resource = client.resource("http://localhost:8080/rest/hi/jax-rs");

    Assert.assertEquals("Hello jax-rs", resource.get(String.class));
}</pre>

        <h3>Un peu de recul</h3>

        <p>La mise en place d'un web service est relativement aisée.</p>

        <p>D'une implémentation à l'autre, il peut y avoir quelques différences pour la mise en place des ressources.</p>

        <p>Il est plus simple d'appeler un service rest qu'un service web mais la différence est plus fondamentale que cela.</p>

        <p>Les apis créées avec des web services sont riches (rpc) et potentiellement complexes.</p>

        <p>L'api d'un service REST est toujours la même (uniforme) : GET, POST, PUT et DELETE.</p>

        <p>En théorie les 2 ne couvrent pas le même genre de besoins.</p>

        <p>Entre les 2, on peut définir des services hybrides qui profitent des technologies liés à REST (http, json...) mais sans en respecter toutes les règles.</p>

        <h2>La liste des billets</h2>

        <p>Comme pour le service web, nous allons exposer nos billets.</p>

        <p>Afin de réutiliser notre service de billets, nous aimerions pouvoir écrire :</p>

        <pre>@Path("/posts")
public class PostsResource {
   @Inject
   private PostService postService;

   @GET
   @Produces(MediaType.APPLICATION_JSON)
   public List&lt;Post&gt; posts() {
       return postService.find(0, 10);
   }
}</pre>

        <p>On rajoute les librairies pour le binding json.</p>

        <pre>&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-jaxrs&lt;/artifactId&gt;
    &lt;version&gt;1.9.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-json&lt;/artifactId&gt;
    &lt;version&gt;1.11&lt;/version&gt;
&lt;/dependency&gt;</pre>

        <p>Et comme pour les services web, il existe un pont entre jersey et spring.</p>

        <p>Il faut utiliser l'extension spring de jersey et jackson pour le binding json.</p>

        <pre>&lt;dependency&gt;
   &lt;groupId&gt;com.sun.jersey.contribs&lt;/groupId&gt;
   &lt;artifactId&gt;jersey-spring&lt;/artifactId&gt;
   &lt;version&gt;1.11&lt;/version&gt;
&lt;/dependency&gt;</pre>

        <p>Et changer la servlet de notre service rest</p>

        <pre>&lt;servlet&gt;
    &lt;servlet-name&gt;rest&lt;/servlet-name&gt;
    &lt;servlet-class&gt;<b>com.sun.jersey.spi.spring.container.servlet.SpringServlet</b>&lt;/servlet-class&gt;
    <span style="text-decoration: line-through;">&lt;init-param&gt;</span>
        <span style="text-decoration: line-through;">&lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;</span>
        <span style="text-decoration: line-through;">&lt;param-value&gt;edu.ecm.blog.rest.BlogApplication&lt;/param-value&gt;</span>
    <span style="text-decoration: line-through;">&lt;/init-param&gt;</span>
    <span class="comment">&lt;!-- autorise le mime type application/json avec jackson --&gt;</span>
    <b>&lt;init-param&gt;
        &lt;param-name&gt;com.sun.jersey.api.json.POJOMappingFeature&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;</b>
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;rest&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre>

        <p>Au lieu de charger une application, notre servlet va maintenant aller chercher ses ressources dans le contexte spring.</p>

        <p>Comme pour le service web, il est nécessaire de rajouter un listener spring afin de charger le post service dans le contexte père</p>

        <p>Dans le contexte père, il suffit de rajouter un scan des composants :</p>

        <pre>&lt;context:component-scan base-package="edu.ecm.blog.rest"/&gt;</pre>

        <p>Et de déclarer nos resources comme des composants spring.</p>

        <pre>@Component
public class PostsResource {
    <span class="comment">...</span>
}</pre>

        <p>Comme rien ne pourrait jamais vraiment marcher du premier coup, il se trouve que l'extension spring de jersey vient avec une dépendance vers spring 2.5.6, ce qui pose des problèmes au démarrage du tomcat (2 versions de spring dans le classpath).</p>

        <p>Maven permet d'exclure des dépendances transitives de jersey-spring :</p>

        <pre>&lt;dependency&gt;
   &lt;groupId&gt;com.sun.jersey.contribs&lt;/groupId&gt;
   &lt;artifactId&gt;jersey-spring&lt;/artifactId&gt;
   &lt;version&gt;1.11&lt;/version&gt;
   &lt;exclusions&gt;
       &lt;exclusion&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring&lt;/artifactId&gt;
       &lt;/exclusion&gt;
       &lt;exclusion&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
       &lt;/exclusion&gt;
       &lt;exclusion&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
       &lt;/exclusion&gt;
       &lt;exclusion&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
       &lt;/exclusion&gt;
       &lt;exclusion&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
       &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;</pre>

        <p>Ce qui donne sur http://localhost:8080/rest/posts</p>

        <pre>[
{"id":5,"title":"un titre selenium 2","date":1325336160000,"slug":"un-titre-selenium-2","author":null,"text":"",
            "tags":""},
{"id":4,"title":"un titre selenium","date":1325334360000,"slug":"un-titre-selenium","author":null,"text":"",
            "tags":""},
{"id":3,"title":"un post","date":1321366380519,"slug":"un-post","author":null,"text":"un peu de texte",
            "tags":"tag 1,tag 2"},
{"id":2,"title":"un post","date":1321366380517,"slug":"un-post","author":null,"text":"un peu de texte",
            "tags":"tag 1,tag 2"},
{"id":1,"title":"un post","date":1321366380424,"slug":"un-post","author":null,"text":"un peu de texte",
            "tags":"tag 1,tag 2"}
]</pre>

        <p>En se basant sur la <a href="http://jersey.java.net/nonav/documentation/latest/json.html" class="external" target="_blank">documentation de Jersey</a>, ecrire un test d'intégration très simple pour ce service.</p>

        <p>Coté client, jersey va mapper le retour vers une liste de map. Si on souhaitait récupérer une liste de Post, il faudrait configurer jackson un peu plus en avant.</p>
    </div>
</div>
</body>
</html>