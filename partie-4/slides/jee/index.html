<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1">
        <title>JEE</title>

        <link href="../../../common/css/css.css" rel="stylesheet" type="text/css">
        <link href="../../../common/css/prettify.css" rel="stylesheet" id="prettify-link">
        <link href="../../../common/css/moon.css" class="theme" rel="stylesheet">
        <link href="../../../common/css/default.css" class="theme" rel="stylesheet">
        <link href="../../../common/css/dev.css" class="theme" rel="stylesheet">

        <script src="../../../common/jquery/jquery-1.4.4.min.js"></script>
        <script src="../../../common/jquery/jquery-ui-1.8.7.custom.min.js"></script>

        <script src="../../../common/js/code.js"></script>
        <script src="../../../common/js/prettify.js" onload="prettyPrint();"></script>
        <script src="../../../common/js/main.js" type="text/javascript"></script>
  	</head>
  	<body>
    <div class="presentation">
      <div id="presentation-counter">Chargement...</div>
      <div style="display: block;" class="slides">
      
	      <div class="slide">
			<style>
			  #landing-slide p {
			    font-size: 35px;
			  }
			</style>
			<section id="landing-slide" class="middle">
			  <p>JEE</p>
			</section>
	      </div>
	      
	      <div class="slide">
	      	<header>Persitence</header>
	        <section>
	        	<p>La correspondance entre un modèle de données objet et une base de données relationnelle est mécanique complexe.</p>
	        	<p>Les solutions <b>ORM</b> (Object Relationnal Mapping) aide à gérer ce problème d'impédance.</p>
	        	<p>Jee propose 2 éléments pour réaliser ce travail.</p>
	        	<ul>
	        		<li>Les <b>entity beans</b> : le modèle de données
	        		<li><b>JPA</b> (java persistence api) : l'API qui permet d'échanger avec la base 
	        	</ul>
	        	<p>A sa base, l'api JPA gère les problématique <b>CRUD</b> en s'appuyant sur la force des bases de données relationlles, le <b>SQL</b> :</p> 
	        	<ul>
	        		<li><b>C</b>reate : persitence d'une entité 
	        		<li><b>R</b>equest : recherche d'entités
	        		<li><b>U</b>pdate : mise à jour d'entités
	        		<li><b>D</b>elete : suppression d'entités
	        	</ul>
	        </section>
	      </div>
	      
	      <div class="slide">
	      	<header>JPA</header>
	        <section>
	        	<p>Voici un exemple de l'utilisation de jpa en envirronement non managé.</p>
	        	<pre>
<span class="comment">// chargement de la définition de la persistence unit depuis persistence.xml</span>
EntityManagerFactory emf = Persitence.createEntityManagerFactory("test-db");
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();

<span class="comment">// Création de l'entité</span>
Person person = new Person();
person.setFirstname("Steven");
person.setLastname("Seagal");

<span class="comment">// Ecriture en base</span>
tx.begin();
em.persist(person);
tx.commit();

<span class="comment">// Libération des ressources</span>
em.close();
emf.close();</pre>
	        	<p>Nous verrons un peu plus tard la définition d'une entité.</p>
	        </section>
	      </div>
	      
	      <div class="slide">
	      	<header>persistence.xml</header>
	        <section>
	        	<p>Le fichier persitence.xml ressemble à l'exemple suivant.</p>
	        	<pre>
&lt;persistence ...&gt;
 &lt;persistence-unit name="test-db" transaction-type="RESOURCE_LOCAL"&gt;
  &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
  &lt;class&gt;<b>fr.prez.Person</b>&lt;/class&gt;
  &lt;properties&gt;
  &lt;property name="hibernate.dialect"
    value="<b>org.hibernate.dialect.HSQLDialect</b>"/&gt;
  &lt;property name="hibernate.hbm2ddl.auto" value="update"/&gt;
  &lt;property name="hibernate.connection.driver_class"
    value="org.hsqldb.jdbcDriver"/&gt;
  &lt;property name="hibernate.connection.username" value="sa"/&gt;
  &lt;property name="hibernate.connection.password" value=""/&gt;
  &lt;property name="hibernate.connection.url"
    value="<b>jdbc:hsqldb:hsql://localhost/testdb</b>"/&gt;
  &lt;/properties&gt;
 &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre>
	        	<p>Dans cet exemple, nous utilisons hibernate avec hsql (base de données embarquée).</p>
	        </section>
	      </div>
	      
	      <div class="slide">
	      	<header>Les EJBs</header>
	        <section>
	         	<p>Les <b>enterprise java beans</b> sont au coeur des serveurs d'application : ils composent les couches métier de l'application.</p>
	         	<p>La version 3.1 (jee 6) facilite énormément la programmation entreprise de java.</p>
	         	<p>Une conteneur d'EJBs propose de nombreux services :</p>
	         	<ul>
	         		<li><b>Cycle de vie</b> : gestion d'un cycle de vie pour les composants
	         		<li><b>Injection de dépendances</b> : aide à la constuction de l'application
	         		<li><b>Intercepteurs</b> : factorisation du code transverse
	         		<li><b>Pooling</b> : pool d'objets afin de gérer la concurrence 
	         		<li><b>Transactions</b> : prise en main des transactions
	         		<li><b>Appels asynchrones</b> : possiblité de déclencher des traitements asynchrones
	         		<li><b>Sécurité</b> : utilisateurs et rôles
	         		<li><b>Communication distante</b> : facilitation des appels à des services distants
	         		<li><b>Messaging</b> : envoi et consommation de messages
	         	</ul>
	         	<p>Nous allons voir les types d'EJB disponibles en version 3.1 et quelques unes de leur possibilités.</p>  
	        </section>
	      </div>
	      
	      <div class="slide">
	      	<header>@Entity</header>
	        <section>
	         	<p>Les beans entités représente le domaine métier de l'application et sont au coeur de la persitence avec la base de données.</p>
	         	<pre>
@Entity
@NamedQuery(name = "findAllPersons", query = "select p from Person p")
public class Person {
   @Id
   @Generated
   private Long id;
   
   private String firstname;
   
   private String lastname;
   
   @Column(length = 1000)
   private String comments;
   
   <span class="comment">// ... getters and setters</span>
}</pre>  
	        </section>
	      </div>
	      
	      <div class="slide">
	      	<header>@Stateless</header>
	        <section>
	         	<p>Les beans de session sans état servent à implémenter la logique métier et la persistence.</p>
	         	<pre>
@Stateless
public class PersonService {
   @PersitenceContext(unitName = "demoPU")
   private EntityManager entityManager;
   
   public void save(Person person) {
      em.persit(person);
   }
   
   public List&lt;Person&gt; findBooks() {
      return em.createNamedQuery("findAllPersons").getResultList();
   }
   
   public String getFullname(Person person) {
      return person.getFirstname() + " " + person.getLastname();
   }
}
</pre>  
				<p>Les beans @Stateless sont gérés dans un pool.</p>
	        </section>
	      </div>
	      
	      <div class="slide">
	      	<header>@Singleton</header>
	        <section>
	         	<p>Les beans de session sans état singleton font exactement comme les beans @Stateless sauf qu'ils ne sont pas gérés en pool.</p>
	         	<pre>
@Singleton
public class PersonService {
   @PersitenceContext(unitName = "demoPU")
   private EntityManager entityManager;
   
   public void save(Person person) {
      entityManager.persit(person);
   }
   
   public List&lt;Person&gt; findBooks() {
      return entityManager.createNamedQuery("findAllPersons").getResultList();
   }
   
   public String getFullname(Person person) {
      return person.getFirstname() + " " + person.getLastname();
   }
}
</pre>  
	        </section>
	      </div>
	      
	      <div class="slide">
	      	<header>@Stateful</header>
	        <section>
	         	<p>Les beans de session avec état gardent leur état entre les appels.</p>
	         	<pre>
@Stateful
@StatefulTimeout(30000)
public class ShoppingCart {
	private List&lt;Item&lt; items = new ArrayList&lt;Item&lt;();
	
	public void add(Item item) { items.add(item); }
	
	public void remove(Item item) { items.remove(item); }
	
	public float total(Item item) {
		float total = 0f;
	
		for (Item item : items) { total += item.getprice(); }
		
		return total;
	}
}
</pre>  
				<p>A cause de leur propriété, ces beans sont parfois appelé beans conversationnels.</p>
	        </section>
	      </div>
	      
	      <div class="slide">
	      	<header>Et encore des annotations</header>
	        <section>
	        	<p>Il est possible de rendre l'exécution de certaines méthodes asynchrone.</p>
	        	<pre>
@Asynchronous
public void processYearReport() {
	<span class="comment">// analyser toutes les données de l'année</span>
	
	<span class="comment">// sauver le résultat en base</span>
}
</pre>
	        	<p>Ou de planifier l'exécution de méthodes.</p>
	        	<pre>
@Schedule(minute = "0/5")
public void refreshCache() {
	<span class="comment">// mettre à jour les caches</span>
}
</pre>
	        </section>
	      </div>
	      
	      <div class="slide">
	      	<header>Le reste des services</header>
	        <section>
	        	<ul>
	        		<li>JAX-WS : les services SOAP
	        		<li>JAX-RX : les servcies REST
	        		<li>JAXB : binding java - xml
	        		<li>JDBC : java database connectivity
	        		<li>JMS : java messaging service
	        		<li>JSF : java server faces
	        		<li>Bean validation : annotations pour la validation
	        		<li>javaMail : envoi et réception de mail
	        		<li>JMX : standardisation du management des applications
	        	</ul>
	        </section>
	      </div>
	
	      <div class="slide">
	      	<header>Forces et faiblesses des serveurs jee</header>
	        <section>
	        	<p>Les spécifications jee sont riches</p>
	        	<ul>
		          	<li>Servlets et jsp forment un couple extrêmement puissant
		          	<li>Les EJBs permettent de définir des composants business distribuables et réutilisables
		          	<li>La liste des services est longue et complète 
		        </ul>
	          	<p>Mais</p>
		       	<ul>
			       	<li>Les premiers pas sont difficiles
			       	<li>La configuration est très verbeuse
			       	<li>Il faut un serveur d'application afin de profiter de toutes les possibilités
		       	</ul>
		       	<p>En 10 ans, jee a su évoluer et combler une partie de ses faiblesses afin de se rendre plus accesible.</p>
	        </section>
	      </div>
	
	      <div class="slide">
	      	<header>A lire</header>
	        <section>
	        	<p>Le livre de référence sur jee 6 de Antonio Goncalves</p>
	        	<div style="margin:100px 150px;">
	        	<img alt="" src="img/jee6-goncalves.gif" width="200px;" style="float:left;margin:10px 20px;">
	        	<ul>
	        		<li>Historique jee
	        		<li>Persistance
	        		<li>Entreprise Java Beans (EJB)
	        		<li>Transactions
	        		<li>Sécurité
	        		<li>Java Server Faces (JSF)
	        		<li>Java Server Pages (JSP)
	        		<li>Java Messaging Service (JMS)
	        		<li>Web services (SOAP et REST)
	        	</ul>
	        	</div>
	        </section>
	      </div>
	     
	  </div>
      <!-- slides -->

    </div> <!-- presentation -->
    
  	</body>
</html>