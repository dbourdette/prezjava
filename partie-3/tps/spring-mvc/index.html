<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1">
    <title>Spring MVC</title>

    <link href="../../../common/css/css.css" rel="stylesheet" type="text/css">
    <link href="../../../common/css/prettify.css" rel="stylesheet" id="prettify-link">
    <link href="../../../common/css/default.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/dev.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/project.css" class="theme" rel="stylesheet">

    <script src="../../../common/js/prettify.js" onload="prettyPrint();"></script>
    <script src="../../../common/js/main.js" type="text/javascript"></script>
</head>
<body>
<div class="presentation">
    <div id="project">
        <h1>Spring MVC</h1>

        <p>Les conteneurs de servlets sont des outils très puissants mais il ne serait pas pratique de construire une application riche avec des servlets.</p>

        <p>Les frameworks MVC pour le web apportent les fonctionnalités manquantes.</p>

        <p>Nous allons travailler avec spring MVC, le module MVC du framework spring.</p>

        <h2>Mise en place</h2>

        <p>En premier, on rajoute les librairies pour spring mvc.</p>

        <pre>
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
    &lt;version&gt;3.0.5.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
   &lt;version&gt;3.0.5.RELEASE&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>

        <p>Dans le web.xml, on rajoute la servlet spring. Elle reçoit toutes les requêtes.</p>
        
        <pre>
<span class="comment">&lt;!-- Spring servlet --&gt;</span>
&lt;servlet&gt;
   &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
   &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
   &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
   &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
   &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre>

        <p>Au démarrage de tomcat, cette servlet va aller charger un contexte spring (/WEB-INF/spring-servlet.xml) qu'il nous faut définir.</p>

        <pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:context="http://www.springframework.org/schema/context"
   xmlns:mvc="http://www.springframework.org/schema/mvc"
   xmlns:tx="http://www.springframework.org/schema/tx"
   xmlns:p="http://www.springframework.org/schema/p"
   xmlns:aop="http://www.springframework.org/schema/aop"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;

   &lt;!-- Support des annotations --&gt;
   &lt;context:annotation-config /&gt;
   
   &lt;!-- Création de composants classiques pour spring mvc --&gt;
   &lt;mvc:annotation-driven /&gt;
   
   &lt;!-- Forwarde les demandes de fichiers statiques vers la servlet par défaut du conteneur --&gt;
   &lt;mvc:default-servlet-handler /&gt;

   &lt;!-- Définition de la Locale pour les opération de formattage --&gt;
    &lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.FixedLocaleResolver"&gt;
        &lt;property name="defaultLocale" value="fr_FR" /&gt;
    &lt;/bean&gt;

   &lt;!-- Configuration de la technologie de rendu  --&gt;
    &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt;
        &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt;
        &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;
        &lt;property name="suffix" value=".jsp" /&gt;
    &lt;/bean&gt;
    
&lt;/beans&gt;</pre>

        <p>Il est temps de rajouter notre premier Controller.</p>

        <h2>HelloController</h2>

        <p>Nous définissons la class HelloController dans le package edu.ecm.blog.web.controller.</p>

        <pre>@Controller
public class HelloController {
   @RequestMapping("/hello")
   public String hello(Model model) {
      model.addAttribute("name", "Steven");
      
      return "hello";
   }
}</pre>

        <p>L'annotation @Controller indique a spring que ce composant est un composant spécial qui répond aux requêtes http.</p>

        <p>L'annotation @RequestMapping fait la liaison entre l'url et la méthode appelée.</p>

        <p>Le Model est ce qui est rempli par le Controller et transmis à la vue.</p>

        <p>Le retour "hello" va être mappé pas le viewResolver et interpreté comme /WEB-INF/jsp/hello.jsp.</p>

        <p>la création d'un Controller est donc plus simple et plus souple qu'une servlet. Le framework nousmp) laisse faire que ce qu'il ne peut faire lui même.</p>

        <p>Afin que ce composant soit chargé, il faut le définir dans le contexte. Comme nous allons faire plusieurs Controller, nous utilisons un scan de package.</p>

        <pre>&lt;context:component-scan base-package="edu.ecm.blog.web.controller" /&gt;</pre>

        <p>Le Controller devrait répondre sur <a href="http://localhost:8080/hello" target="_blank">http://localhost:8080/hello</a> en lançant l'application avec la commande mvn tomcat:run.</p>

        <h2>La home page</h2>
        
        <p>Pour notre home, nous allons utiliser le template <a href="files/index.jsp" target="_blank">index.jsp</a> à placer dans WEB-INF/jsp.</p>

        <p>La feuille de style est <a href="files/style.css" target="_blank">style.css</a> à placer dans src/main/webapp/css afin que le lien depuis la jsp soit valide.</p>

        <p>Le Controller associé est le suivant.</p>

        <pre>@Controller
public class IndexController {
   @RequestMapping("/index")
   public String index() {
      return "index";
   }
}</pre>

        <p>Pour le moment, les données sont en dur dans la jsp, mais <a href="http://localhost:8080/index" target="_blank">http://localhost:8080/index</a> est disponible.</p>

        <h2>Les services</h2>

        <p>Nous allons maintenant ajouter nos services dans le contexte spring afin de les rendre accessibles depuis les Controllers.</p>

        <p>Comme pour les Controllers, nous allons utiliser un scan.</p>

        <pre>&lt;context:component-scan base-package="edu.ecm.blog.service"/&gt;</pre>

        <p>Et les 2 implémentations des services doivent être annoté avec @Service</p>

        <pre>@Service
public class PostServiceImpl implements PostService</pre>

        <p>Ainsi les services du package seront chargés dans le contexte spring au démarrage de l'application.</p>

        <h2>La base de données</h2>
        
        <p>Comme pour les tests unitaires, il manque la définition de la session factory et de la connexion à la base.</p>

        <p></p>

        <pre>&lt;!-- pool de connexion --&gt;
&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="org.apache.derby.jdbc.EmbeddedDriver"/&gt;
    &lt;property name="url" value="jdbc:derby:target/<b>blogdb</b>;create=true"/&gt;
    &lt;property name="username" value=""/&gt;
    &lt;property name="password" value=""/&gt;
&lt;/bean&gt;

&lt;!-- factory bean pour la SessionFactory hibernate --&gt;
&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="hibernateProperties"&gt;
        &lt;bean class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
            &lt;property name="properties"&gt;
                &lt;props&gt;
                    &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.DerbyDialect&lt;/prop&gt;
                    &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt;
                &lt;/props&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="packagesToScan" value="edu.ecm.blog.domain"/&gt;
&lt;/bean&gt;

&lt;!-- ajoute un gestionnaire de transactions lié à la sessionFactory --&gt;
&lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
&lt;/bean&gt;

&lt;!-- active le support des annotations @Transactional --&gt;
&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;</pre>

        <p>La configuration est quasi identique à la configuration des tests.</p>

        <p>Pour une application réelle, nous n'utiliserions pas une base embarquée.</p>

        <p>Nous utiliserions une url qui pointe vers la base comme par exemple : jdbc:mysql://host:3306/blogdb.</p>

        <h2>Bootstrap</h2>

        <p>En l'état, l'application démarre sans erreur mais les données sont toujours en dur dans la page jsp.</p>

        <p>Nous allons donc initialiser le contenu de la base de données au démarrage.</p>

        <p>Dans la classe IndexController on rajoute une méthode bootstrap</p>

        <pre>@PostConstruct
public void bootstrap() {

}</pre>

        <p>@PostConstruct est une annotation java standard qui marque une méthode a appeler après la construction du composant.</p>

        <p>L'appel est fait après injection des dépendances.</p>

        <p>L'alter ego de @PostConstruct est @PreDestroy, appelé juste avant la destruction du composant.</p>

        <p>En injectant le PostService dans le Controller, implémenter le pseudo code suivant :</p>

        <pre>if (pas de billet) {
    créer 3 billets en remplissant tous les champs (sauf l'auteur)
}</pre>

        <h2>L'injection des valeurs dans le Model</h2>

        <p>Afin d'injecter notre attribut dans le modèle, il suffit de demander le modèle à Spring</p>

        <pre>@RequestMapping("/index")
public String index(Model model) {
    return "index";
}</pre>

        <p>Il existe plusieurs façons d'interagir avec le Model et celle-ci est la plus simple.</p>

        <p>Il reste donc a ajouter les 10 derniers billets dans le modèle.</p>

        <pre>model.addAttribute("posts", postService.find(0, 10));</pre>

        <h2>La jsp</h2>

        <p>La jsp correspond à l'étape de rendu. On y produit le code html.</p>

        <p>Les jsp dispose de 2 outils principaux pour mettre en forme :</p>

        <ul>
            <li>L'expression language (EL) : une notation qui permet de naviguer dans les propriétés des objets</li>
            <li>La java standard tag lib (JSTL) : une notation xml qui permet d'appeler du code java</li>
        </ul>

        <p>Un <a href="http://adiguba.developpez.com/tutoriels/j2ee/jsp/jstl/" class="external" target="_blank">bon tutorial sur la jstl</a> est disponible sur le site de developpez.com</p>

        <p>Afin de pouvoir utiliser la jstl, il faut ajouter une implémentation dans le pom.xml</p>

        <pre>&lt;dependency&gt;
   &lt;groupId&gt;taglibs&lt;/groupId&gt;
   &lt;artifactId&gt;standard&lt;/artifactId&gt;
   &lt;version&gt;1.1.2&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency></pre>

        <p>Et déclarer les taglibs utilsées en haut du fichier jsp.</p>

        <pre>&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %&gt;</pre>

        <p>En utilisant les notations suivantes, mettre en forme la jsp afin qu'elle produise la liste des billets.</p>

        <p>L'itération :</p>

        <pre>&lt;c:forEach var="post" items="${posts}"&gt;...&lt;/c:forEach&gt;</pre>

        <p>L'expression language :</p>

        <pre>${post.title} ${post.text} ${post.tags} ${post.author.name}</pre>

        <p>Le formattage de date :</p>

        <pre>&lt;fmt:formatDate value="${post.date}" pattern="dd MMM yyyy à HH'h'mm"/&gt;</pre>

        <p>La liste des billets n'est donc plus qu'une itération dans un attribut du modèle.</p>

        <h2>La page de billet</h2>

        <p>Le controller</p>

        <h2>La gestion des billets</h2>

        <p>Le template</p>

        <p>Le controller</p>

        <p>pagination, gestion des auteurs</p>

    </div>
</div>
</body>
</html>