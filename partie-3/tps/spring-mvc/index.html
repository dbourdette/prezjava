<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1">
    <title>Spring MVC</title>

    <link href="../../../common/css/css.css" rel="stylesheet" type="text/css">
    <link href="../../../common/css/prettify.css" rel="stylesheet" id="prettify-link">
    <link href="../../../common/css/default.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/dev.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/project.css" class="theme" rel="stylesheet">

    <script src="../../../common/js/prettify.js" onload="prettyPrint();"></script>

</head>
<body>
<div class="presentation">
    <div id="project">
        <h1><img src="img/spring.png" alt="" style="margin-right:5px;height:40px;position: relative;top:6px;">Spring MVC</h1>

        <p>Les conteneurs de servlets sont des outils très puissants et très ouverts.</p>
        
        <p>Mais il ne serait pas pratique de construire une application riche avec des servlets.</p>

        <img src="img/container.png" alt="" style="margin: 0 150px;">

        <p>Les frameworks MVC pour le web apportent les fonctionnalités manquantes.</p>

        <p>Nous allons travailler avec spring MVC, le module MVC du framework spring.</p>

        <h2>Mise en place</h2>

        <p>En premier, on rajoute les librairies pour spring mvc.</p>

        <pre>
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
    &lt;version&gt;3.0.5.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
   &lt;version&gt;3.0.5.RELEASE&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>

        <p>Dans le web.xml, on rajoute la servlet spring. Elle reçoit toutes les requêtes.</p>
        
        <pre>
<span class="comment">&lt;!-- Spring servlet --&gt;</span>
&lt;servlet&gt;
   &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
   &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
   &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
   &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
   &lt;url-pattern&gt;<b>/</b>&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre>

        <p>Au démarrage de tomcat, cette servlet va aller charger un contexte spring (/WEB-INF/spring-servlet.xml) qu'il nous faut définir.</p>

        <pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:context="http://www.springframework.org/schema/context"
   xmlns:mvc="http://www.springframework.org/schema/mvc"
   xmlns:tx="http://www.springframework.org/schema/tx"
   xmlns:p="http://www.springframework.org/schema/p"
   xmlns:aop="http://www.springframework.org/schema/aop"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;

   &lt;!-- Support des annotations --&gt;
   &lt;context:annotation-config /&gt;
   
   &lt;!-- Création de composants classiques pour spring mvc --&gt;
   &lt;mvc:annotation-driven /&gt;
   
   &lt;!-- Forwarde les demandes de fichiers statiques vers la servlet par défaut du conteneur --&gt;
   &lt;mvc:default-servlet-handler /&gt;

   &lt;!-- Définition de la Locale pour les opération de formattage --&gt;
   &lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.FixedLocaleResolver"&gt;
       &lt;property name="defaultLocale" value="fr_FR" /&gt;
   &lt;/bean&gt;

   &lt;!-- Configuration de la technologie de rendu  --&gt;
   &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt;
       &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt;
       &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;
       &lt;property name="suffix" value=".jsp" /&gt;
   &lt;/bean&gt;

&lt;/beans&gt;</pre>

        <p>Il est temps de rajouter notre premier Controller.</p>

        <h2>HelloController</h2>

        <p>Nous définissons la classe HelloController dans le package edu.ecm.blog.web.controller.</p>

        <pre>@Controller
public class HelloController {
   @RequestMapping("/hello")
   public String hello(Model model) {
      model.addAttribute("name", "Steven");
      
      return "hello";
   }
}</pre>

        <p>L'annotation @Controller indique a spring que ce composant est un composant spécial qui répond aux requêtes http.</p>

        <p>L'annotation @RequestMapping fait la liaison entre l'url du service et la méthode cible de la classe.</p>

        <p>Le Model est ce qui est rempli par le Controller et transmis à la vue.</p>

        <p>Le retour "hello" va être mappé pas le viewResolver (avec le prefix et suffix de la configuration spring) et interpreté comme /WEB-INF/jsp/hello.jsp.</p>

        <p>La création d'un Controller est une opération simple et les annotations apportent de la souplesse.</p>

        <p>Afin que ce composant soit chargé, il faut le définir dans le contexte. Comme nous allons faire plusieurs Controller, nous utilisons un scan de package.</p>

        <pre>&lt;context:component-scan base-package="edu.ecm.blog.web.controller" /&gt;</pre>

        <p>Le Controller devrait répondre sur <a href="http://localhost:8080/hello" target="_blank">http://localhost:8080/hello</a> en lançant l'application avec la commande mvn tomcat:run.</p>

        <h2>La home page</h2>
        
        <p>Pour notre home, nous allons utiliser le template <a href="files/index.jsp" target="_blank">index.jsp</a> à placer dans WEB-INF/jsp.</p>

        <p>La feuille de style est <a href="files/style.css" target="_blank">style.css</a> à placer dans src/main/webapp/css afin que le lien depuis la jsp soit valide.</p>

        <p>Le Controller associé est le suivant.</p>

        <pre>@Controller
public class IndexController {
   @RequestMapping("/index")
   public String index() {
      return "index";
   }
}</pre>

        <p>Pour le moment, les données sont en dur dans la jsp, mais <a href="http://localhost:8080/index" target="_blank">http://localhost:8080/index</a> est disponible.</p>

        <h2>Les services</h2>

        <p>Nous allons maintenant ajouter nos services dans le contexte spring afin de les rendre accessibles depuis les Controllers.</p>

        <p>Comme pour les Controllers, nous allons utiliser un scan.</p>

        <pre>&lt;context:component-scan base-package="edu.ecm.blog.service"/&gt;</pre>

        <p>Et les 2 implémentations des services doivent être annoté avec @Service</p>

        <pre>@Service
public class PostServiceImpl implements PostService</pre>

        <p>Ainsi les services du package seront chargés dans le contexte spring au démarrage de l'application.</p>

        <p>Les services sont chargés mais cela produit une erreur car aucune session factory n'est présente dans notre contexte spring.</p>

        <h2>La base de données</h2>
        
        <p>Comme pour les tests unitaires, il manque la définition de la session factory et de la connexion à la base.</p>

        <p></p>

        <pre>&lt;!-- pool de connexion --&gt;
&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="org.apache.derby.jdbc.EmbeddedDriver"/&gt;
    &lt;property name="url" value="jdbc:derby:target/<b>blogdb</b>;create=true"/&gt;
    &lt;property name="username" value=""/&gt;
    &lt;property name="password" value=""/&gt;
&lt;/bean&gt;

&lt;!-- factory bean pour la SessionFactory hibernate --&gt;
&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="hibernateProperties"&gt;
        &lt;bean class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
            &lt;property name="properties"&gt;
                &lt;props&gt;
                    &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.DerbyDialect&lt;/prop&gt;
                    &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt;
                &lt;/props&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="packagesToScan" value="edu.ecm.blog.domain"/&gt;
&lt;/bean&gt;

&lt;!-- ajoute un gestionnaire de transactions lié à la sessionFactory --&gt;
&lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
&lt;/bean&gt;

&lt;!-- active le support des annotations @Transactional --&gt;
&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;</pre>

        <p>La configuration est quasi identique à la configuration des tests.</p>

        <p>Pour une application réelle, nous n'utiliserions pas une base embarquée.</p>

        <p>Nous utiliserions une url qui pointe vers la base comme par exemple : jdbc:mysql://host:3306/blogdb.</p>

        <h2>Bootstrap</h2>

        <p>En l'état, l'application démarre sans erreur mais les données sont toujours en dur dans la page jsp.</p>

        <p>Afin de pouvoir afficher des données dans la page, nous allons initialiser la base de données au démarrage de l'application.</p>

        <p>Dans la classe IndexController on rajoute une méthode bootstrap</p>

        <pre>@PostConstruct
public void bootstrap() {

}</pre>

        <p>@PostConstruct est une annotation java standard qui marque une méthode a appeler après la construction du composant.</p>

        <p>L'appel est fait après injection des dépendances.</p>

        <p>L'alter ego de @PostConstruct est @PreDestroy, appelé juste avant la destruction du composant.</p>

        <p>En injectant le PostService dans le Controller, implémenter le pseudo code suivant :</p>

        <pre>if (pas de billet) {
    créer 3 billets en remplissant tous les champs (sauf l'auteur)
}</pre>

        <h2>L'injection des valeurs dans le Model</h2>

        <p>Afin d'injecter notre attribut dans le modèle, il suffit de demander le modèle à Spring</p>

        <pre>@RequestMapping("/index")
public String index(<b>Model model</b>) {
    return "index";
}</pre>

        <p>Il existe plusieurs façons d'interagir avec le Model et celle-ci est la plus simple.</p>

        <p>Il reste donc a ajouter les 10 derniers billets dans le modèle.</p>

        <pre>model.addAttribute("posts", postService.find(0, 10));</pre>

        <h2>La jsp</h2>

        <p>La jsp correspond à l'étape de rendu. On y produit le code html.</p>

        <p>Les jsp dispose de 2 outils principaux pour mettre en forme :</p>

        <ul>
            <li>L'expression language (EL) : une notation qui permet de naviguer dans les propriétés des objets</li>
            <li>La java standard tag lib (JSTL) : une notation xml qui permet d'appeler du code java</li>
        </ul>

        <p>On peut également définir et utiliser ses propres tag libs.</p>

        <p>Un <a href="http://adiguba.developpez.com/tutoriels/j2ee/jsp/jstl/" class="external" target="_blank">bon tutorial sur la jstl</a> est disponible sur le site de developpez.com</p>

        <p>Afin de pouvoir utiliser la jstl, il faut ajouter une librairie d'implémentation dans le pom.xml</p>

        <pre>&lt;dependency&gt;
   &lt;groupId&gt;taglibs&lt;/groupId&gt;
   &lt;artifactId&gt;standard&lt;/artifactId&gt;
   &lt;version&gt;1.1.2&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency></pre>

        <p>Et déclarer les taglibs utilsées en haut du fichier jsp.</p>

        <pre>&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %&gt;</pre>

        <p>En utilisant les notations suivantes, mettre en forme la jsp afin qu'elle produise la liste des billets.</p>

        <p>L'itération :</p>

        <pre>&lt;c:forEach var="post" items="${posts}"&gt;...&lt;/c:forEach&gt;</pre>

        <p>L'expression language :</p>

        <pre>${post.title} ${post.text} ${post.tags} ${post.author.name}</pre>

        <p>Le formattage de date :</p>

        <pre>&lt;fmt:formatDate value="${post.date}" pattern="dd MMM yyyy à HH'h'mm"/&gt;</pre>

        <p>La liste des billets n'est donc plus qu'une itération dans un attribut du modèle.</p>

        <h2>La page de billet</h2>

        <p>La page du billet est assez similaire à la page d'index.</p>

        <p><a href="files/post.jsp" target="_blank">Le template de la page</a> est le même avec un unique billet.</p>

        <p>Nous pouvons créer une seconde méthode dans le Controller.</p>

        <pre><b>@RequestMapping("/billet/{slug}")</b>
public String post(<b>@PathVariable</b> String slug, Model model) {
    model.addAttribute("post", postService.<b>findBySlug</b>(slug));

    return "post";
}</pre>

        <p>Le mapping contient une partie qui correspond à un paramètre de la méthode.</p>

        <p>Et nous avons ajouté une méthode à notre service.</p>

        <p>Il reste donc plusieurs choses à faire :</p>

        <ul>
            <li>implémenter la méthode findBySlug()</li>
            <li>intégrer le template html</li>
            <li>rajouter des liens sur les titres des billets de la home page vers la page de billet</li>
        </ul>

        <p>Le Controller faisant maintenant un peu plus que la page d'index, nous pouvons le renommer BlogController.</p>

        <p>Il s'agit d'un refactoring utile qui permet au nom du composant d'être en phase avec son utilité.</p>

        <p>Les annotations facilitent ces refactorings.</p>

        <h2>La gestion des billets</h2>

        <p>Nous allons construire un CRUD (Create Request Update Delete) pour les billets.</p>

        <p>Nous commençons par créer un nouveau Controller</p>

        <pre>@Controller
public class AdminController {
}</pre>

        <p>Celui va devoir supporter les opérations suivantes :</p>

        <ul>
            <li>Liste des billets actuellement en base avec un lien "nouveau"</li>
            <li>Le formulaire pour un nouveau billet</li>
            <li>La sauvegarde du nouveau billet</li>
            <li>Le formulaire pour l'édition d'un billet</li>
            <li>La sauvegarde d'une billet</li>
            <li>La suppression d'un billet</li>
        </ul>

        <h3>La liste des billets</h3>

        <p>Ecrire une méthode qui réponde sur /admin/posts qui injecte la totalité des billets dans le modèle.</p>

        <p>Cette méthode doit ensuite rediriger vers la vue /WEB-INF/jsp/admin/posts.jsp/</p>

        <p>En s'inspirant de la page d'index, écrire le fichier jsp en le remplissant avec la liste des titres des billets.</p>

        <p>Le lien sur le titre du billet doit pointer vers /admin/post/{id du billet}.</p>

        <p>Un lien en haut de la jsp doit pointer vers /admin/post avec un texte "nouveau".</p>

        <h3>Un nouveau billet</h3>

        <p>On ajoute une méthode au Controller pour la création d'un nouveau billet.</p>

        <pre>@RequestMapping("/admin/post")
public String post(Model model) {
    <span class="comment">// on injecte un Post vierge dans le modèle</span>
    model.addAttribute("post", new Post());

    return "admin/post";
}</pre>

        <p>La vue est <a href="files/form.jsp">un formulaire</a> qui permet d'éditer les attributs du billet.</p>

        <p>On y trouve l'appel à la taglib de spring pour les formulaires.</p>

        <pre>&lt;%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %&gt;</pre>

        <p>Le formulaire qui reprend le nom du bean dans le modèle, l'url cible et la méthode HTTP.</p>

        <pre>&lt;form:form commandName="post" action="/admin/post" method="post"&gt;</pre>

        <p>Un champs input est facile à définir.</p>

        <pre>&lt;form:input path="title" /&gt;</pre>

        <p>Avec un zone prévue pour afficher les messages d'erreurs.</p>

        <pre>&lt;form:errors path="title" /&gt;</pre>

        <p>En attendant le HTML 5 (et encore, cela ne sera pas fantastique), les inputs html sont un peu limités.</p>

        <p>Les formulaires spring sont extrêmement proche des formulaires html standards.</p>

        <h3>La gestion du POST</h3>

        <p>Coté jsp, tout est en place. Il reste a gérer la réception des données coté serveur.</p>

        <p>Le mapping suivant permet de recevoir l'appel.</p>

        <pre>@RequestMapping(value = "/admin/post", method = RequestMethod.<b>POST</b>)
public String post(<b>@ModelAttribute("post")</b> Post post, <b>BindingResult</b> bindingResult, Model model) {
   ...
}</pre>

        <p>En recevant l'appel, spring va "binder" le contenu de la requête http à notre objet.</p>

        <p>BindingResult contient toutes les erreurs de validation. C'est ce qui permet l'affichage des erreurs dans la jsp.</p>

        <p>Le minimum vital pour notre billet est le titre. On fait donc une vérification et on sauve le billet en base.</p>

        <span class="todo">IMPORT COMMONS LANG</span>
        
        <pre>if (StringUtils.isEmpty(post.getTitle())) {
    bindingResult.rejectValue("title", "field.empty", "Le titre est obligatoire");

    return "admin/post";
}

postService.save(post);

return "redirect:/admin/posts";</pre>

        <p>StringUtils vient de la librairie commons lang qu'il faut ajouter au pom</p>

        <pre>&lt;dependency&gt;
    &lt;groupId&gt;commons-lang&lt;/groupId&gt;
    &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>

        <p>Si on tente de sauvegarder un billet en l'état, nous avons un message d'erreur nous indiquant que spring ne parvient pas a convertir une chaîne de caractères en date.</p>

        <pre>Failed to convert property value of type java.lang.String to required type java.util.Date for property date;
nested exception is org.springframework.core.convert.ConversionFailedException:
Unable to convert value "" from type java.lang.String to type java.util.Date;
nested exception is java.lang.IllegalArgumentException</pre>

        <p>En effet spring n'adopte pas de convention par défaut et ne sait pas quel est le format littéral d'une date.</p>

        <p>Il faut alors configurer le binder dans notre Controller.</p>

        <pre>@InitBinder
public void binder(WebDataBinder binder) {
    SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");

    binder.registerCustomEditor(Date.class, new CustomDateEditor(sdf, true));
}</pre>

        <p>Le format de date est donc "dd/MM/yyyy HH:mm" et il est possible d'avoir une date vide.</p>

        <p>Désormais, la sauvegarde fonctionne.</p>

        <p>Afin de nous simplifier l'édition, on peut d'ailleurs initialiser le champs date à la date courante dans le modèle.</p>

        <pre>@Column
@Temporal(TemporalType.TIMESTAMP)
private Date date = new Date();</pre>

        <h3>L'édition</h3>

        <p>A ce point, l'édition d'un billet est simple. Il faut ajouter le mapping dans le Controller.</p>

        <pre>@RequestMapping("/admin/post/{id}")
public String post(@PathVariable Long id, Model model) {
    // on injecte le post
    model.addAttribute("post", postService.<b>findById</b>(id));

    return "admin/post";
}</pre>

        <p>Il faut créer la méthode findById dans le service afin que ce code fonctionne.</p>

        <p>Dans le cas de l'édition d'un billet, on utilise le même formulaire.</p>

        <p>Il faut juste rajouter le champs id afin que le celui-ci soit renvoyé au moment du post du formulaire.</p>

        <pre>&lt;form:hidden path="id" /&gt;</pre>

        <p>Un dernier point : la méthode save de PostServiceImpl fait un session.save(post). Cela crée un nouvel enregistrement en base même si le billet a un déjà un id.</p>

        <p>On remplace session.save(post) par session.saveOrUpdate(post) et l'édition de billet fonctionne.</p>

        <h3>La suppression</h3>

        <p>Rajouter un mapping sur /admin/post/{id}/delete qui supprime un post.</p>

        <p>Ajouter un lien pour chaque billet dans le listing.</p>

        <h3>Un peu d'ordre</h3>

        <p>En jouant avec l'édition des billets, on observe qu'ils ne sont pas classés par date.</p>

        <p>Cela se corrige simplement en ajoutant une clause order dans la méthode find du service :</p>

        <pre>criteria.addOrder(Order.desc("date"));</pre>

        <p>Les billets les plus récents sont en premier.</p>

        <h3>JSR 303</h3>

        <p>Nous avons effectué la validation dans le Controller.</p>

        <p>Cette possibilité est simple mais deviendrait dense si il fallait valider beaucoup de champs.</p>

        <p>Nous allons maintenant utiliser une technique beaucoup plus concise : la <a href="http://jcp.org/en/jsr/detail?id=303" target="_blank" class="external">JSR 303</a> (spécification bean validation).</p>

        <p>Tout d'abord, il faut importer une librairie d'implémentation de la spécification.</p>

        <pre><span class="comment">&lt;!-- hibernate validator --&gt;</span>
&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
   &lt;version&gt;4.2.0.Final&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>

        <p>Hibernate validator est la spécification de référence.</p>

        <p>Nous pouvons alors modifier l'AdminController</p>

        <pre>@RequestMapping(value = "/admin/post", method = RequestMethod.POST)
public String post(@ModelAttribute("post") <b>@Valid</b> Post post, BindingResult bindingResult, Model model) {
   <s>if (StringUtils.isEmpty(post.getTitle())) {
       bindingResult.rejectValue("title", "field.empty", "Le titre est obligatoire");

       return "admin/post";
   }</s>

   <b>if (bindingResult.hasErrors()) {
       return "admin/post";
   }</b>

   postService.save(post);

   return "redirect:/admin/posts";
}</pre>

        <p>L'annotation @Valid indique a spring qu'il doit exécuter un validateur sur l'attribut.</p>

        <p>Il nous suffit alors d'annoter le champs title de la class Post :</p>

        <pre>@Column
<b>@NotEmpty</b>
private String title;</pre>

        <p>En tant qu'implémentation de la JSR 303, hibernate validator vient avec la prise en charge des annotations et un jeu de messages d'erreur localisé.</p>

        <img src="img/jsr-303.png" alt="" style="margin: 0 100px">

        <p>Il est maintenant très simple de rajouter d'autres @NotEmpty ou bien @Length ou @Email.</p>

        <p>Il est même possible d'écrire ses propres annotations afin de rendre réutilisable simplement ses éléments de validation.</p>

        <h2>En peu de recul</h2>

        <p>L'utilisation des Controllers est simple mais il nous a fallu bien des librairies et quelques fichiers de configuration pour arriver à ce résultat.</p>

        <p>Dans le cadre d'un projet maven + spring mvc, obtenir sa première page n'est pas instantané.</p>

        <p>D'autres frameworks (rails, grails, roo, play...) offrent un démarrage rapide et beaucoup de vitesse pour les besoins classiques (le CRUD est un des exemples courants)</p>

        <p>Spring mvc de son coté est un peu plus lourd à manipuler mais est d'une très grande flexibilité.</p>

        <p>Selon les projets, on peut donc choisir la technologie la plus adaptée.</p>

        <h2>Le reste</h2>

        <p>Il resterait beaucoup a faire afin d'avoir une application complète.</p>

        <p>Voici quelques pistes / questions pour la suite :</p>

        <ul>
            <li>La page d'index est /index. Comment pourrait on faire pour que / réponde également comme page d'index ?</li>
            <li>Comment devrait on gérer la pagination ? Quelle ergonomie dans la page ? Quelles modifications dans le service ?</li>
            <li>Comment pourrait on gérer convenablement le bloc de tag ?</li>
            <li>Comment lister les billets par tags (et donc pour mettre des liens sur les tags) ?</li>
            <li>Comment faire fonctionner le bloc des derniers billets ?</li>
            <li>La gestion des auteurs est un élément délicat. Comment gérer la relation @ManyToOne dans le formulaire d'édition ? Comment gérer cela dans le controller et le service ?</li>
            <li>La gestion des cas d'erreur : que faire de http://localhost:8080/billet/not-existing-post ou bien http://localhost:8080/admin/post/aaa ?</li>
            <li>Si notre blog devait supporter beaucoup de trafic, que pourrait on faire pour l'aider à tenir la charge ?</li>
        </ul>

    </div>
</div>
</body>
</html>