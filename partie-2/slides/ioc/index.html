<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	    <meta charset="utf-8">
	    <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1">
	    <title>L'injection de dépendances</title>
	    
		<link href="../../../common/css/css.css" rel="stylesheet" type="text/css">
        <link href="../../../common/css/prettify.css" rel="stylesheet" id="prettify-link">
        <link href="../../../common/css/moon.css" class="theme" rel="stylesheet">
        <link href="../../../common/css/default.css" class="theme" rel="stylesheet">
        <link href="../../../common/css/dev.css" class="theme" rel="stylesheet">

        <script src="../../../common/jquery/jquery-1.4.4.min.js"></script>
        <script src="../../../common/jquery/jquery-ui-1.8.7.custom.min.js"></script>

        <script src="../../../common/js/code.js"></script>
        <script src="../../../common/js/prettify.js" onload="prettyPrint();"></script>
        <script src="../../../common/js/main.js" type="text/javascript"></script>
  	</head>
  	<body>
    <div class="presentation">
      <div id="presentation-counter">Chargement...</div>
      <div style="display: block;" class="slides">

              <div class="slide">
                <style>
                  #landing-slide p {
                    font-size: 35px;
                  }
                </style>
                <section id="landing-slide" class="middle">
                  <p>L'injection de dépendances</p>
                </section>
              </div>

              <div class="slide">
                <header>Une solution à un problème</header>
                <section>
                    <p>Le code suivant est problématique.</p>
                    <pre>
public class SimpleService {
   private Database database;

   public SimpleService() {
      this.database = new Database(...);
   }

   public void updateDatabase() {
      database.doUpdateDatabase();
   }
   ...
}</pre>
                    <ul>
                        <li>Le constructeur entreprend des opérations risquées : que se passe t il en cas d'exception ?</li>
                        <li>Le service instancie et configure lui même la connexion : ce n'est pas son rôle.</li>
                        <li>Il est diffcile de rendre paramétrable la configuration de l'instance database.</li>
                        <li>L'instance database ne peut pas être partagée entre plusieurs services.</li>
                        <li>Qui libère la ressource database lorsque SimpleService n'est plus utile ?</li>
                    </ul>
                </section>
              </div>

              <div class="slide">
                <header>La collaboration entre les objets</header>
                <section>
                    <p>Les problèmes grandissent avec la taille de l'application.</p>
                    <p>Il est nécessaire d'adopter une méthode systématique efficace.</p>
                </section>
              </div>

              <div class="slide">
                <header>Une solution</header>
                <section>
                    <p>Pour bien définir la responsabilité de chaque composant, l'application doit alors déléguer :</p>
                    <ul>
                        <li>La création et la configuration des composants</li>
                        <li>La gestion du cycle de vie des composants</li>
                    </ul>
                    <p>Concrêtement, un service n'instancie pas d'autres services, il obtient des références.</p>
                    <p>Les composants abandonnent ce qui n'est pas à eux au bénéfice d'un chef d'orchestre.</p>
                    <br>
                    <p>Cette démarche est appelée <b>Inversion of Control</b>.</p>
                    <br>
                    <ul>
                        <li>La démarche de conception objet est libérée et la définition des classes est plus simple.</li>
                        <li>Le coupable entre les classe est plus faible.</li>
                        <li>Les tests unitaires sont plus simples à écrire.</li>
                    </ul>
                </section>
              </div>

              <div class="slide">
                <header>Inversion of control</header>
                <section>
                    <p>Il existe plusieurs techniques afin de mettre en place l'IoC.</p>
                    <img alt="" src="img/ioc.png" width="500px" style="margin:0 150px;">
                    <ul>
                        <li>Le <b>service locator</b> permet d'obtenir des références à partir d'un registre centralisé
                        <li>L'<b>injection par constructeur</b> apporte les dépendances lors de l'appel au constructeur
                        <li>L'<b>injection par setter</b> apporte les dépendances en utilisant les accesseurs (setters)
                    </ul>
                    <p>Une explication plus longue sur ces différentes options est disponible sur la page <a href="http://martinfowler.com/articles/injection.html" class="external" target="_blank">Inversion of Control</a> du site de Martin Fowler.</p>
                </section>
              </div>

              <div class="slide">
                <header>Les conteneurs légers</header>
                <section>
                    <p>Ils sont apparus vers 2003 et reposent sur l'injection de dépendances.</p>
                    <ul>
                        <li>La mise en place est simple</li>
                        <li>L'empreinte mémoire est faible</li>
                        <li>Le temps de démarrage est court</li>
                        <li>Ils favorisent les bonnes pratiques objet</li>
                        <li>Il est possible de faire fonctionner l'application en dehors d'un serveur d'application</li>
                    </ul>
                    <p>Les conteneurs léger les plus connus sont : <b>spring framework</b>, <b>picocontainer</b> et <b>guice</b>.</p>
                </section>
              </div>

              <div class="slide">
                <header>POJOs</header>
                <section>
                    <p>Les conteneurs légers glorifient les Plain Old Java Objects (<b>POJOs</b>) : la bonne vieille conception objet.</p>
                    <p style="font-size: 26px;margin:20px 0 0 20px;">Nous nous sommes demandés pourquoi tout le monde était autant contre l'utilisation d'objets simples dans leurs systèmes et nous avons conclu que c'était parce que ces objets simples n'avaient pas un nom sympa. Alors, on leur en a donné un et ça a pris tout de suite</a></p>
                    <p style="float:right;margin:10px 20px 0 0px;"><i>Martin Fowler, Rebecca Parsons et Josh MacKenzie</i></p>
                    <div style="clear:both;"></div>
                    <p>Ce n'est pas une idée neuve, c'est un retour à de bonnes pratiques de conception objet.</p>
                    <p>Au début des frameworks d'IoC, jee pronait la conception 3 tiers sur un mode de pensée unique.</p>
                    <p>Aujourd'hui, les spécifications jee ont adopté une posture similaire et faire des EJBs n'a plus grand chose à voir avec les pratiques de cette époque.</p>
                </section>
              </div>

              <div class="slide">
                <header>Spring framework</header>
                <section>
                    <p><a href="http://www.springsource.org/" target="_blank" class="external">Spring</a> est un conteneur léger par injection de dépendances.</p>
                    <img alt="" src="img/spring-overview.png" width="500px" style="margin:0 150px;">
                    <p>En plus de l'IoC, c'est une boite à outils riche pour les applications jee.</p>
                    <p>Une vision rapide de ce que fait spring est disponible sur la page d'<a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/overview.html" class="external" target="_blank">introduction à spring</a></p>
                </section>
              </div>

              <div class="slide">
                <header>Démarrage d'un contexte spring</header>
                <section>
                    <p>La configuration canonique de spring se fait via un fichier xml contenant des beans.</p>
                    <pre>
    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;beans&gt;

      &lt;bean id="..." class="..."&gt;
        &lt;!-- configuration du bean ici --&gt;
      &lt;/bean&gt;

      &lt;!-- plus de beans ici --&gt;

    &lt;/beans&gt;</pre>
                    <p>Qui peut être chargé avec le code suivant</p>
                    <pre>
    ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml");</pre>
                    <p>L'injection des liens entre les beans est appelée <b>wiring</b>.</p>
                </section>
              </div>

              <div class="slide">
                <header>Des beans spring</header>
                <section>
                    <p>Imaginons deux services qui collaborent.</p>
                    <pre>
    public interface ServiceA {
       public void doSomethingUseful();
    }

    public class ServiceAImpl implements ServiceA {
       public void doSomethingUseful() { ... }
    }

    public class ServiceB {
       private ServiceA serviceA;
       public void setServiceA(ServiceA serviceA) {this.serviceA = serviceA;}
       public void call() { serviceA.doSomethingUseful(); }
    }</pre>
                    <p>Voici la configuration spring nécessaire.</p>
                    <pre>
    &lt;bean id="serviceA" class="x.y.z.ServiceAImpl" /&gt;

    &lt;bean id="serviceB" class="x.y.z.ServiceB"&gt;
        &lt;property name="serviceA" ref="serviceA"&gt;
    &lt;/bean&gt;</pre>
                </section>
              </div>

              <div class="slide">
                <header>@Inject</header>
                <section>
                    <p>Il existe une alternative avec des annotations afin d'injecter les dépendances.</p>
                    <pre>
    public class ServiceB {
       <b>@Inject</b>
       private ServiceA serviceA;

       public void call() { serviceA.doSomethingUseful(); }
    }</pre>
                    <p>Avec le contexte suivant.</p>
                    <pre>
    &lt;context:annotation-config/&gt; <span class="comment">&lt;!-- active les annotations --&gt;</span>

    &lt;bean id="serviceA" class="x.y.z.ServiceAImpl" /&gt;

    &lt;bean id="serviceB" class="x.y.z.ServiceB" /&gt;
    </pre>
                    <p>@Inject est le standard jee, spring supporte aussi sa propre annotation @Autowired et une autre annotation standard @Resource.</p>
                </section>
              </div>

              <div class="slide">
                <header>@Component</header>
                <section>
                    <p>On peut aussi demander à spring de chercher les composants dans le classpath.</p>
                    <pre>
    &lt;context:annotation-config/&gt; <span class="comment">&lt;!-- active les annotations --&gt;</span>
    &lt;context:component-scan base-package="x.y.z"/&gt; <span class="comment">&lt;!--scan le package x.y.z--&gt;</span>
    </pre>

                    <p>Les composants doivent juste être annotés</p>
                    <pre>
    <b>@Service</b>
    public class ServiceAImpl implements ServiceA {
       public void doSomethingUseful() { ... }
    }

    <b>@Service</b>
    public class ServiceB {
       @Inject
       private ServiceA serviceA;

       public void call() { serviceA.doSomethingUseful(); }
    }</pre>
                    <p>Les @Component peuvent être des @Service, @Repository ou bien des @Controller.</p>
                </section>
              </div>

              <div class="slide">
                <header>Projet spring</header>
                <section>
                    <p>Un squelette du projet est disponible dans le répertoire <a href="projets/ioc/index.html" class="project" target="_blank">projets/ioc</a>.</p>
                    <p>Nous utilisons <a href="http://eclipse.org" class="external" target="_blank">eclipse</a> comme IDE.</p>
                    <p>Nous utilisons <a href="http://lucene.apache.org/solr/" class="external" target="_blank">solr</a> comme moteur de recherche et base de données orientée document.</p>
                    <p><br><br></p>
                    <p>Nous allons construire une base de moteur de recherche web.</p>
                </section>
              </div>


              <div class="slide">
                <header>AOP Proxies</header>
                <section>
                    <p>Lors du wiring, spring peut intercaler des classes entre l'appelant et la cible.</p>
                    <img alt="" src="images/aop-proxy.png" width="500px" style="margin:0 150px;">
                    <p>Cette approche est appelée <b>Aspect Oriented Programming</b> et peut être mis en place de plusieurs façons :</p>
                    <ul>
                        <li>Création d'un <b>proxy dynamique</b> : création d'une classe à partir d'un interface (jdk)
                        <li>à la <b>compilation</b> : les aspects sont ajoutés au moment de la compilation
                        <li>au <b>chargement</b> : les aspects sont ajoutés au moment du démarrage de l'application.
                    </ul>
                    <p>C'est particulièrement utile afin de factoriser des traitements <b>orthogonaux</b> au code métier.</p>
                    <p>La nomenclature de l'AOP est complexe : advice, crosscuting, join point, point cut..., mais le principe reste simple : exécuter du code entre l'appelant et l'objet cible.</p>
                </section>
              </div>

              <div class="slide">
                <header>Gestion de transaction</header>
                <section>
                    <p>Le gestion des resources liées aux transactions est lourde à manipuler.</p>
                    <pre>
    public void doSomethingUseful() {
      Connection con = null;

      try {
        con = dataSource.getConnection();
        con.setAutoCommit(false); <span class="comment">// Activer les transactions</span>

        <b>stmt = con.createStatement();
        stmt.executeUpdate("update my_table set stock = 3 where id = 15");</b>

        con.commit(); <span class="comment">// Commit de la transaction</span>
      } catch (Exception e) {
        <span class="comment">// Rollback de la transaction en cas d'erreur</span>
        if (con != null) { con.rollback(); }
      } finally {
        <span class="comment">// Libération des ressources</span>
        if (con != null) { con.close(); }
      }
    }</pre>
                </section>
              </div>

              <div class="slide">
                <header>@Transactional</header>
                <section>
                    <p>Grâce à l'AOP et un gestionnaire de transaction, on peut simplifier le code précédent.</p>
                    <pre>
    <b>@Transactional</b>
    public void doSomethingUseful() {
      Connection conn = DataSourceUtils.getConnection(dataSource);

      stmt = con.createStatement();
      stmt.executeUpdate("update my_table set stock = 3 where id = 15");
    }</pre>
                    <p>Avec la configuration suivante</p>
                    <pre>
    <span class="comment">&lt;!-- activer les annotations @Transactional --&gt;</span>
    &lt;tx:annotation-driven transaction-manager="txManager"/&gt;

    <span class="comment">&lt;!-- le gestionnaire de transaction --&gt;</span>
    &lt;bean id="txManager"
        class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
       <span class="comment">&lt;!-- la dataSource est définie ailleurs --&gt;</span>
       &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;</pre>
                </section>
              </div>

              <div class="slide">
                <header>Déclarer son propre aspect</header>
                <section>
                    <p>La détection d'aspects est activée avec la configuration suivante.</p>
                    <pre>&lt;aop:aspectj-autoproxy/&gt;</pre>
                    <p>Et pour Créer un aspect afin d'afficher le temps de calcul de chaque méthode.</p>
                    <pre>
    @Aspect
    @Component
    public class TraceAspect {
       @Around("within(fr.prez.ioc..*)")
       public Object trace(ProceedingJoinPoint pjp) throws Throwable {
          long t1 = System.currentTimeMillis();

          <b>Object value = pjp.proceed()</b>;

          long t2 = System.currentTimeMillis();

          System.out.println("Executed " + pjp.getSignature() + " in " +
             (t2 - t1) + "ms");

          return value;
       }
    }</pre>
                </section>
              </div>

              <div class="slide">
                <header>Autres services</header>
                <section>
                    <p>Spring c'est un conteneur léger mais aussi une boite à outils.</p>
                    <ul>
                        <li>Accès aux données : support pour les <b>ORM</b> et jdbc
                        <li>Mapping Objet - Xml (<b>OXM</b>) : support pour JAXB, Castor, XMLBeans, JiBX et XStream
                        <li>Framework <b>MVC 2</b> et Portlets
                        <li><b>Remoting</b> : RMI, HTTP, REST, Burlap, Hessian...
                        <li>Intégration avec les <b>EJBs</b>
                        <li><b>Message Driven Beans</b> et envoi de messages <b>JMS</b>
                        <li>Simplification de <b>JMX</b>
                        <li>Envoi d'<b>email</b>
                        <li>Simples <b>schedulers</b> et support pour <b>Quartz</b>
                        <li>Et biens d'autres au travers de modules...
                    </ul>
                    <p>L'étendue de ses capacités a porté spring bien au-delà d'un framework IOC.</p>
                    <p>Il est donc difficilement comparable à d'autres framework IOC.</p>
                    <p>Spring est davantage une alternative à la façon de faire du composant jee en entreprise.</p>
                </section>
              </div>

              <div class="slide">
                <header>A Lire</header>
                <section>
                    <p>La philosophie derrière spring et conteneurs légers.</p>
                    <img alt="" src="images/jee-without-ejb-johnson.jpg" width="250px" style="margin:0 250px;">
                    <p>Expert One-on-One J2EE Development without EJB / Rod Johnson &amp; Juergen Hoeller</p>
                    <p>Et la <a href="http://www.springsource.org/documentation" class="external" target="_blank">documentation spring</a></p>
                </section>
              </div>

          </div>
          <!-- slides -->

        </div> <!-- presentation -->
    
  	</body>
  </html>