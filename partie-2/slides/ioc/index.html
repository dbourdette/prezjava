<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	    <meta charset="utf-8">
	    <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1">
	    <title>L'injection de dépendances</title>
	    
		<link href="../../../common/css/css.css" rel="stylesheet" type="text/css">
        <link href="../../../common/css/prettify.css" rel="stylesheet" id="prettify-link">
        <link href="../../../common/css/moon.css" class="theme" rel="stylesheet">
        <link href="../../../common/css/default.css" class="theme" rel="stylesheet">
        <link href="../../../common/css/dev.css" class="theme" rel="stylesheet">

        <script src="../../../common/jquery/jquery-1.4.4.min.js"></script>
        <script src="../../../common/jquery/jquery-ui-1.8.7.custom.min.js"></script>

        <script src="../../../common/js/code.js"></script>
        <script src="../../../common/js/prettify.js" onload="prettyPrint();"></script>
        <script src="../../../common/js/main.js" type="text/javascript"></script>
  	</head>
  	<body>
    <div class="presentation">
      <div id="presentation-counter">Chargement...</div>
      <div style="display: block;" class="slides">

              <div class="slide">
                <style>
                  #landing-slide p {
                    font-size: 35px;
                  }
                </style>
                <section id="landing-slide" class="middle">
                  <p>L'injection de dépendances</p>
                </section>
              </div>

              <div class="slide">
                <header>Un problème de design</header>
                <section>
                    <p>Le code suivant est problématique.</p>
                    <pre>
public class SimpleService {
   private Database database;

   public SimpleService() {
      this.database = new Database(...);
   }

   public void updateDatabase() {
      database.doUpdateDatabase();
   }
   ...
}</pre>
                    <ul>
                        <li>Le constructeur entreprend des opérations risquées : que se passe t il en cas d'exception ?</li>
                        <li>Le service instancie et configure lui même la connexion : ce n'est pas son rôle.</li>
                        <li>Il est diffcile de rendre paramétrable la configuration de l'instance database.</li>
                        <li>L'instance database ne peut pas être partagée entre plusieurs services.</li>
                        <li>Qui libère la ressource database lorsque SimpleService n'est plus utile ?</li>
                    </ul>
                </section>
              </div>

              <div class="slide">
                <header>La collaboration entre les objets</header>
                <section>
                    <p>Le problème grandit rapidement avec la taille de l'application.</p>
                    <img src="img/class-diagram.png" style="margin-left:150px;">
                    <p>Comment instancier et lier tous ces objets entre eux ?</p>
                    <p>Il est nécessaire d'adopter une méthode systématique efficace.</p>
                </section>
              </div>

              <div class="slide">
                <header>Une solution</header>
                <section>
                    <p>On divise la vie de l'application en 2 temps</p>
                    <ul>
                        <li>La mise en place des composants : instanciation et wiring</li>
                        <li>Le fonctionnement nominal de l'application</li>
                    </ul>
                    <p>Le code applicatif délègue la première partie de sa vie à un chef d'orchestre.</p>
                    <p>Celui-ci gère le cycle de vie des objets : instanciation, wiring et libération.</p>
                    <br>
                    <ul>
                        <li>La définition des classes est plus simple.</li>
                        <li>Le couplage entre les classes est plus faible.</li>
                        <li>Les tests unitaires sont plus simples à écrire.</li>
                    </ul>
                    <br>
                    <p>Cette démarche est appelée <b>Inversion of Control</b>.</p>
                </section>
              </div>

              <div class="slide">
                <header>Inversion of control</header>
                <section>
                    <p>Il existe plusieurs techniques afin de mettre en place l'IoC.</p>
                    <img alt="" src="img/ioc.png" width="500px" style="margin:0 150px;">
                    <ul>
                        <li>Le <b>service locator</b> permet d'obtenir des références à partir d'un registre centralisé
                        <li>L'<b>injection par constructeur</b> apporte les dépendances lors de l'appel au constructeur
                        <li>L'<b>injection par setter</b> apporte les dépendances en utilisant les accesseurs (setters)
                    </ul>
                    <p>Une explication plus longue sur ces différentes options est disponible sur la page <a href="http://martinfowler.com/articles/injection.html" class="external" target="_blank">Inversion of Control</a> du site de Martin Fowler.</p>
                </section>
              </div>

              <div class="slide">
                <header>Les conteneurs légers</header>
                <section>
                    <p>Ils sont apparus vers 2003 et reposent sur l'injection de dépendances.</p>
                    <ul>
                        <li>La mise en place est simple</li>
                        <li>L'empreinte mémoire est faible</li>
                        <li>Le temps de démarrage est court</li>
                        <li>Ils favorisent les bonnes pratiques objet</li>
                        <li>Il est possible de faire fonctionner l'application en dehors d'un serveur d'application</li>
                    </ul>
                    <p>Les conteneurs léger les plus connus sont : <b>spring framework</b>, <b>picocontainer</b> et <b>guice</b>.</p>
                </section>
              </div>

              <div class="slide">
                <header>POJOs</header>
                <section>
                    <p>Les conteneurs légers glorifient les Plain Old Java Objects (<b>POJOs</b>) : la bonne vieille conception objet.</p>
                    <p style="font-size: 26px;margin:20px 0 0 20px;">Nous nous sommes demandés pourquoi tout le monde était autant contre l'utilisation d'objets simples dans leurs systèmes et nous avons conclu que c'était parce que ces objets simples n'avaient pas un nom sympa. Alors, on leur en a donné un et ça a pris tout de suite</a></p>
                    <p style="float:right;margin:10px 20px 0 0px;"><i>Martin Fowler, Rebecca Parsons et Josh MacKenzie</i></p>
                    <div style="clear:both;"></div>
                    <p>Ce n'est pas une idée neuve, c'est un retour à de bonnes pratiques de conception objet.</p>
                    <p>Au début des frameworks d'IoC, jee pronait la conception 3 tiers sur un mode de pensée unique.</p>
                    <p>Aujourd'hui, les spécifications jee ont adopté une posture similaire et faire des EJBs n'a plus grand chose à voir avec les pratiques de cette époque.</p>
                </section>
              </div>

              <div class="slide">
                <header>Spring framework</header>
                <section>
                    <p><a href="http://www.springsource.org/" target="_blank" class="external">Spring</a> est un conteneur léger par injection de dépendances.</p>
                    <img alt="" src="img/spring-overview.png" width="500px" style="margin:0 150px;">
                    <p>En plus de l'IoC, c'est une boite à outils riche pour les applications jee.</p>
                    <p>Une vision rapide de ce que fait spring est disponible sur la page d'<a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/overview.html" class="external" target="_blank">introduction à spring</a></p>
                </section>
              </div>

              <div class="slide">
                <header>Démarrage d'un contexte spring</header>
                <section>
                    <p>La configuration canonique de spring se fait via un fichier xml définissant le context spring.</p>
                    <pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans&gt;

  &lt;bean id="<span class="comment">...</span>" class="<span class="comment">...</span>"&gt;
    <span class="comment">&lt;!-- configuration du bean ici --&gt;</span>
  &lt;/bean&gt;

  <span class="comment">&lt;!-- plus de beans ici --&gt;</span>

&lt;/beans&gt;</pre>
                    <p>C'est une liste de beans qui seront chargés au démarrage de l'application.</p>
                    <p>Le contexte peut être chargé avec le code suivant</p>
                    <pre>
ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml");</pre>
                </section>
              </div>

              <div class="slide">
                <header>Des beans spring</header>
                <section>
                    <p>Imaginons deux services qui collaborent.</p>
                    <img src="img/spring-beans.png" style="margin-left: 220px;">
                    <p>Voici la configuration spring nécessaire.</p>
                    <pre>
&lt;bean id="simpleService" class="x.y.z.SimpleService"&gt;
    &lt;property name="otherService" ref="otherService"&gt;
&lt;/bean&gt;

&lt;bean id="otherService" class="x.y.z.OtherService" /&gt;</pre>
                    <p>Et la récupération d'un bean dans le contexte.</p>
                    <pre>SimpleService simpleService = (SimpleService) ctx.getBean("simpleService")</pre>
                </section>
              </div>

              <div class="slide">
                <header>@Inject</header>
                <section>
                    <p>Il est possible d'activiter les annotations afin d'injecter les dépendances.</p>
                    <pre>
    public class SimpleService {
       <b>@Inject</b>
       private OtherService otherService;

       public void call() { otherService.doSomethingUseful(); }
    }</pre>
                    <p>Avec le contexte suivant.</p>
                    <pre>
<span class="comment">&lt;!-- active les annotations --&gt;</span>
&lt;context:annotation-config/&gt;

&lt;bean id="serviceA" class="x.y.z.ServiceAImpl" /&gt;

&lt;bean id="serviceB" class="x.y.z.ServiceB" /&gt;</pre>
                    <p><b>@Inject</b> est le standard jee, spring supporte aussi sa propre annotation <b>@Autowired</b> et une autre annotation standard <b>@Resource</b>.</p>
                </section>
              </div>

              <div class="slide">
                <header>@Component</header>
                <section>
                    <p>On peut aussi demander à spring de chercher les composants dans le classpath.</p>
                    <pre>
<span class="comment">&lt;!--scan le package x.y.z--&gt;</span>
&lt;context:component-scan base-package="x.y.z"/&gt;</pre>

                    <p>Tous les composants annotés dans les packages sous x.y.z seront chargés.</p>
                    <pre>
<b>@Service</b>
public class OtherService {
   public void doSomethingUseful() { ... }
}

<b>@Service</b>
public class SimpleService {
   @Inject
   private OtherService otherService;

   public void call() { otherService.doSomethingUseful(); }
}</pre>
                    <p><b>@Component</b> est l'annotation générique.</p>
                    <p><b>@Service</b>, <b>@Repository</b> ou bien <b>@Controller</b> sont plus précis sémantiquement.</p>
                </section>
              </div>

              <div class="slide">
                <header>Aspect Oriented Programming</header>
                <section>
                    <p>La délégation du wiring à spring offre la possibilté d'intercaler du code entre les appels.</p>
                    <img alt="" src="images/aop-proxy.png" width="500px" style="margin:0 150px;">
                    <p>Cette approche est appelée <b>Aspect Oriented Programming</b> et peut être mis en place de plusieurs façons :</p>
                    <ul>
                        <li>Création d'un <b>proxy dynamique</b> : création d'une classe à partir d'un interface (jdk)
                        <li>à la <b>compilation</b> : les aspects sont ajoutés au moment de la compilation
                        <li>au <b>chargement</b> : les aspects sont ajoutés au moment du démarrage de l'application.
                    </ul>
                    <p>C'est particulièrement utile afin de factoriser des traitements <b>orthogonaux</b> au code métier.</p>
                    <p>La nomenclature de l'AOP est complexe : advice, crosscuting, join point, point cut..., mais le principe reste simple : exécuter du code entre l'appelant et l'objet cible.</p>
                </section>
              </div>

              <div class="slide">
                <header>Exemple AOP : les transactions</header>
                <section>
                    <p>La gestion des transactions est lourde.</p>
                    <pre>
    public void doSomethingUseful() {
      Connection con = null;

      try {
        con = dataSource.getConnection();
        con.setAutoCommit(false); <span class="comment">// Activer les transactions</span>

        <b>stmt = con.createStatement();
        stmt.executeUpdate("update my_table set stock = 3 where id = 15");</b>

        con.commit(); <span class="comment">// Commit de la transaction</span>
      } catch (Exception e) {
        <span class="comment">// Rollback de la transaction en cas d'erreur</span>
        if (con != null) { con.rollback(); }
      } finally {
        <span class="comment">// Libération des ressources</span>
        if (con != null) { con.close(); }
      }
    }</pre>
                    <p>Sauf que ce code de gestion est toujours le même.</p>
                </section>
              </div>

              <div class="slide">
                <header>@Transactional</header>
                <section>
                    <p>Grâce à l'AOP et un gestionnaire de transaction, on peut simplifier le code précédent.</p>
                    <pre>
<b>@Transactional</b>
public void doSomethingUseful() {
  Connection conn = DataSourceUtils.getConnection(dataSource);

  stmt = con.createStatement();
  stmt.executeUpdate("update my_table set stock = 3 where id = 15");
}</pre>
                    <p>Avec la configuration suivante</p>
                    <pre>
<span class="comment">&lt;!-- activer les annotations @Transactional --&gt;</span>
&lt;tx:annotation-driven transaction-manager="txManager"/&gt;

<span class="comment">&lt;!-- le gestionnaire de transaction --&gt;</span>
&lt;bean id="txManager"
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
   <span class="comment">&lt;!-- la dataSource est définie ailleurs --&gt;</span>
   &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</pre>
                </section>
              </div>

              <div class="slide">
                <header>Autres services</header>
                <section>
                    <p>Spring c'est un conteneur léger mais aussi une boite à outils.</p>
                    <ul>
                        <li>Accès aux données : support pour les <b>ORM</b> et jdbc
                        <li>Mapping Objet - Xml (<b>OXM</b>) : support pour JAXB, Castor, XMLBeans, JiBX et XStream
                        <li>Framework <b>MVC 2</b> et Portlets
                        <li><b>Remoting</b> : RMI, HTTP, REST, Burlap, Hessian...
                        <li>Intégration avec les <b>EJBs</b>
                        <li><b>Message Driven Beans</b> et envoi de messages <b>JMS</b>
                        <li>Simplification de <b>JMX</b>
                        <li>Envoi d'<b>email</b>
                        <li>Simples <b>schedulers</b> et support pour <b>Quartz</b>
                        <li>Et biens d'autres au travers de modules...
                    </ul>
                    <p>L'étendue de ses capacités a porté spring bien au-delà d'un framework IOC.</p>
                    <p>Il est donc difficilement comparable à d'autres framework IOC.</p>
                    <p>Spring est davantage une alternative à la façon de faire du composant jee en entreprise.</p>
                </section>
              </div>

              <div class="slide">
                <header>A Lire</header>
                <section>
                    <p>La philosophie derrière spring et conteneurs légers.</p>
                    <img alt="" src="images/jee-without-ejb-johnson.jpg" width="250px" style="margin:0 250px;">
                    <p>Expert One-on-One J2EE Development without EJB / Rod Johnson &amp; Juergen Hoeller</p>
                    <p>Et la <a href="http://www.springsource.org/documentation" class="external" target="_blank">documentation spring</a></p>
                </section>
              </div>

          </div>
          <!-- slides -->

        </div> <!-- presentation -->
    
  	</body>
  </html>