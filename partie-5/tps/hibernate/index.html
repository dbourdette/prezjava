<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1">
    <title>Hibernate</title>

    <link href="../../../common/css/css.css" rel="stylesheet" type="text/css">
    <link href="../../../common/css/prettify.css" rel="stylesheet" id="prettify-link">
    <link href="../../../common/css/default.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/dev.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/project.css" class="theme" rel="stylesheet">

    <script src="../../../common/js/prettify.js"></script>

</head>
<body onload="prettyPrint();">
<div class="presentation">
    <div id="project">
        <h1><img src="img/hibernate.png" width="300px"></h1>

        <h2>Introduction</h2>

        <p>Hibernate est un framework de persitence objet - base de données relationnelles.</p>

        <p>Il implémente et étend JPA (Java Persitance API), le standard de persistence jee.</p>

        <img src="img/another-layer.png" alt="" style="margin: 0 250px;">
        
        <p>Techniquement, c'est une surcouche de JDBC qui en simplifie grandement l'usage.</p>

        <h2>Configuration hibernate</h2>

        <p>Comme pour la configuration de derby, nous allons écrire un test unitaire afin de mettre en place notre couche de persistance.</p>

        <p>Nous créons un test HibernateTest dans le package fr.todooz.hibernate.</p>

        <pre class="prettyprint">@Test
public void createSessionFactory() {
   Configuration configuration = new Configuration();

   configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.DerbyDialect");
   configuration.setProperty("hibernate.connection.url", "jdbc:derby:target/testdb;create=true");
   configuration.setProperty("hibernate.connection.driver_class", "org.apache.derby.jdbc.EmbeddedDriver");
   configuration.setProperty("hibernate.hbm2ddl.auto", "create-drop");

   SessionFactory sessionFactory = configuration.buildSessionFactory();
}</pre>

        <p>C'est l'équivalent de la création de la connexion en JDBC. Un peu plus long mais aussi plus riche.</p>

        <p>Le guide complet de la <a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/session-configuration.html" class="external" target="_blank">configuration de hibernate</a></p>

        <p>Ce test ne passe que si on ajoute les entrées suivantes dans le pom.xml</p>

        <pre class="prettyprint">&lt;dependency&gt;
  &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
  &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
  &lt;version&gt;3.6.4.Final&lt;/version&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;javassist&lt;/groupId&gt;
  &lt;artifactId&gt;javassist&lt;/artifactId&gt;
  &lt;version&gt;3.12.1.GA&lt;/version&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
  &lt;version&gt;1.6.1&lt;/version&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>

        <p>Ce test génère pas mal de traces dans la console au démarrage d'hibernate.</p>

        <p>La SessionFactory que l'on récupère est un wrapper autour des APIs JDBC.</p>

        <p>Elle permet de récupérer une Session qui est le pendant d'une Connection JDBC.</p>

        <h2>Les classes du domaine</h2>

        <p>Avant de pouvoir utiliser concrètement notre SessionFactory, il faut lui donner la configuration des classes que l'on veut persiter.</p>

        <p>La façon la plus simple est de le faire via des annotations dans nos classes du domaine.</p>

        <p>On ajoute les annotations @Entity, @Table, @Column.</p>

        <pre class="prettyprint">@Entity
@Table(name = "task")
public class Task {
    @Column
    private Date createdAt = new Date();

    @Column
    private String title;

    @Column(length = 4000, nullable = true)
    private String text;

    @Column
    private Date date;

    @Column(nullable = true)
    private String tags;

    ...
}</pre>

        <p>Il est aussi possible de tout configurer (hibernate et objets du domaine) via fichiers xml mais cela est beaucoup plus verbeux.</p>

        <p>Il ne reste qu'à informer hibernate de la présence de notre bean annoté.</p>

        <pre class="prettyprint">configuration.addAnnotatedClass(Task.class);</pre>

        <p>Une exécution en l'état nous indique que :</p>

        <pre class="prettyprint">org.hibernate.AnnotationException: No identifier specified for entity: fr.todooz.domain.Task
   at org.hibernate.cfg.InheritanceState.determineDefaultAccessType(InheritanceState.java:268)
   at org.hibernate.cfg.InheritanceState.getElementsToProcess(InheritanceState.java:223)
   at org.hibernate.cfg.AnnotationBinder.bindClass(AnnotationBinder.java:686)
   at org.hibernate.cfg.Configuration$MetadataSourceQueue.processAnnotatedClassesQueue(Configuration.java:4035)
   at org.hibernate.cfg.Configuration$MetadataSourceQueue.processMetadata(Configuration.java:3989)
   at org.hibernate.cfg.Configuration.secondPassCompile(Configuration.java:1398)
   at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1856)
   at fr.todooz.hibernate.HibernateTest.createSessionFactory(HibernateTest.java:23)
   at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
   at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
   at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
   at java.lang.reflect.Method.invoke(Method.java:597)
   at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
   at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
   at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
   at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
   at org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)
   at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)
   at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)
   at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
   at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
   at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
   at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
   at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
   at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
   at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:49)
   at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
   at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
   at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
   at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
   at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)</pre>

        <p>Pour corriger cette erreur, il suffit de rajouter un identifiant unique dans chaque classe.</p>

        <pre class="prettyprint">@Id
@GeneratedValue(strategy = GenerationType.AUTO)
private Long id;

public Long getId() {
  return id;
}

public void setId(Long id) {
  this.id = id;
}</pre>

        <p>Cet identifiant servira de clé primaire dans la base de données.</p>

        <p>Il utilise une stratégie de génération automatique : hibernate demandera à la base de générer des identifiants quand il en aura besoin.</p>

        <p>Désormais, ce test unitaire passe.</p>

        <h2>Persister un objet</h2>

        <p>Afin de voir ce que peut faire hibernate, nous allons persister une Task. On ajoute le test suivant.</p>

        <pre class="prettyprint">@Test
public void saveTask() {
    Task task = new Task();

    task.setDate(new Date());
    task.setTitle("Read Effective Java");
    task.setText("Read Effective Java before it's too late");
    task.setTags("java,java");

    Session session = sessionFactory.openSession();

    session.save(task);

    session.close();
}</pre>

        <p>Afin de pouvoir écrire ce test il faut avoir passé le test précédent (createSessionFactory) en @Before au lieu de @Test afin d'initialiser la SessionFactory.</p>

        <p>Hibernate nous permet donc de sauver un objet dans une table sans que nous ayons à manipuler de SQL.</p>

        <p>De même que pour les tests jdbc, nous ne fermons pas correctement notre Session si jamais une erreur survient.</p>

        <p>Comme nous sommes dans du code de test, cela est suffisant pour le moment.</p>

        <p>Malgré cela, nous devons quand même bien nettoyer la base après notre test et fermer la SessionFactory.</p>

        <pre class="prettyprint">@After
public void cleanDb() {
    Session session = sessionFactory.openSession();

    session.createQuery("<b>delete from Task</b>").executeUpdate();

    session.close();

    sessionFactory.close();
}</pre>

        <p>Cette opération de delete est dite "bulk" (en masse) car elle affecte un nombre inconnu, à priori, d'entités.</p>

        <h2>Rechercher un objet</h2>

        <p>Rechercher un objet dans la base se fait tout aussi simplement que la persistence.</p>

        <p>Pour les requêtes, hibernate utilise un language proche du SQL : le <a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/queryhql.html" class="external" target="_blank">HQL</a> (Hibernate Query Language).</p>

        <p>Le HQL permet de travailler avec le nom des attributs des classes au lieu du nom des colonnes en base.</p>

        <pre class="prettyprint">@Test
public void findTask() {
    saveTask();

    Session session = sessionFactory.openSession();

    Query query = session.createQuery("from Task where title = :title");

    query.setString("title", "Read Effective Java");

    List&lt;Task&gt; tasks = query.list();

    session.close();

    Assert.assertEquals(1, tasks.size());
    Assert.assertEquals("Read Effective Java", tasks.get(0).getTitle());
}</pre>

        <p>Avec hibernate on récupère directement nos objets à partir de la base (au lieu d'un ResultSet).</p>

        <p>En plus du HQL, il existe une autre API encore plus orientée objet : la <a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/querycriteria.html" class="external" target="_blank">Criteria API</a></p>

        <pre class="prettyprint">@Test
public void findTaskCriteria() {
    saveTask();

    Session session = sessionFactory.openSession();

    Criteria criteria = session.createCriteria(Task.class);

    criteria.add(Restrictions.eq("title", "Read Effective Java"));

    List&lt;TasK&gt; tasks = criteria.list();

    session.close();

    Assert.assertEquals(1, tasks.size());
    Assert.assertEquals("Read Effective Java", tasks.get(0).getTitle());
}</pre>

        <p>Ces 2 APIs sont disponibles en fonction du besoin.</p>

        <h2>TaskService</h2>

        <p>Avec hibernate nous allons pouvoir écrire simplement notre service de gestion de tâches.</p>

        <p>Les opérations à supporter sont :</p>

        <ul>
            <li>save(task) : persister une tâche en base</li>
            <li>delete(id) : supprimer un tâche</li>
            <li>findAll() : la liste complète des tâches</li>
            <li>findByQuery(String query) : recherche de tâches</li>
            <li>count() : le nombre total de tâches en base</li>
        </ul>

        <p>On pourra rajouter d'autres méthodes plus tard.</p>

        <p>On crée donc la classe TaskService dans fr.todooz.service.</p>

        <pre class="prettyprint">public class TaskService {
   public void save(Task task) {
      <span class="comment">// TODO</span>
   }

   public void delete(Long id) {
      <span class="comment">// TODO</span>
   }

   public List&lt;Task&gt; findAll() {
      <span class="comment">// TODO</span>
   }

   public List&lt;Task&gt; findByQuery(String query) {
      <span class="comment">// TODO</span>
   }

   public int count() {
      <span class="comment">// TODO</span>
   }
}</pre>

        <p>Afin d'implémenter ces méthodes, nous allons passer par des tests unitaires.</p>

        <pre class="prettyprint">public class TaskServiceTest {
   private SessionFactory sessionFactory;

   @Before
   public void createSessionFactory() {
      Configuration configuration = new Configuration();

      configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.DerbyDialect");
      configuration.setProperty("hibernate.connection.url", "jdbc:derby:target/testdb;create=true");
      configuration.setProperty("hibernate.connection.driver_class", "org.apache.derby.jdbc.EmbeddedDriver");
      configuration.setProperty("hibernate.hbm2ddl.auto", "create-drop");

      configuration.addAnnotatedClass(Task.class);

      sessionFactory = configuration.buildSessionFactory();
   }

   @After
   public void cleanDb() {
      Session session = sessionFactory.openSession();

      Transaction transaction = session.beginTransaction();

      session.createQuery("delete from Task").executeUpdate();

      transaction.commit();

      session.close();

      sessionFactory.close();
   }

   @Test
   public void save() {

   }

   private Task task() {
      Task task = new Task();
      task.setDate(new Date());
      task.setTitle("Read Effective Java");
      task.setText("Read Effective Java before it's too late");
      task.setTags("java,java");
      return task;
   }
}</pre>

        <p>Et nous commençons par la méthode save. Nous souhaiterions pouvoir écrire :</p>

        <pre class="prettyprint">@Test
public void save() {
    TaskService taskService = new TaskService();
    taskService.setSessionFactory(sessionFactory);

    taskService.save(task());
}</pre>

        <p>Faites en sorte que cela soit possible et que ce test passe en prenant soin de bien fermer la session.</p>

        <p>Le delete (<a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/queryhql.html#queryhql-bulk" class="external" target="_blank">doc hibernate</a>).</p>

        <pre class="prettyprint">@Test
public void delete() {
    TaskService taskService = new TaskService();
    taskService.setSessionFactory(sessionFactory);

    Task task = task();

    taskService.save(task);

    taskService.delete(task.getId());

    Session session = sessionFactory.openSession();

    Assert.assertEquals(0, session.createQuery("from Task").list().size());

    session.close();
}</pre>

        <p>Les find avec la <a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/querycriteria.html" class="external" target="_blank">criteria API</a></p>

        <pre class="prettyprint">@Test
public void findAll() {
    TaskService taskService = new TaskService();
    taskService.setSessionFactory(sessionFactory);

    taskService.save(task());
    taskService.save(task());

    Assert.assertEquals(2, taskService.findAll().size());
}

@Test
public void findByQuery() {
    TaskService taskService = new TaskService();
    taskService.setSessionFactory(sessionFactory);

    taskService.save(task());
    taskService.save(task());

    Assert.assertEquals(2, taskService.findByQuery("read").size());
    Assert.assertEquals(2, taskService.findByQuery("java").size());
    Assert.assertEquals(0, taskService.findByQuery("driven").size());
}</pre>

        <p>Et le count</p>

        <pre class="prettyprint">@Test
public void count() {
    TaskService taskService = new TaskService();
    taskService.setSessionFactory(sessionFactory);

    taskService.save(task());
    taskService.save(task());

    Assert.assertEquals(2, taskService.count());
}</pre>

        <p>Après ce test, notre service est donc suffisament opérationnel pour le moment.</p>

        <p>Cependant, nous avons un peu de duplication de code dans nos tests unitaires et le code reste assez verbeux.</p>

        <p>Sans casser les tests, il serait possible de grandement simplifier ce code.</p>

        <h2>Les limites</h2>

        <p>Tout ce que nous avons écrit aurait été très verbeux en SQL.</p>

        <p>Hibernate est une aide précieuse lorsque l'on travaille avec des objets et une base de données relationelles.</p>

        <p>Mais notre code a encore quelques limitations :</p>

        <ul>
            <li>Gestion des ouvertures et fermetures de sessions à la main.</li>
            <li>Il faut fournir la SessionFactory au service.</li>
            <li>Pas de gestion de transaction.</li>
            <li>Nous n'utilisons pas de pool de connexion sérieux (hibernate fournit un pool par défaut suffisant pour les tests).</li>
            <li>La mise en place de la SessionFactory n'est pas facilement factorisable.</li>
        </ul>

        <p>Avant de coder un second service, nous allons nous tourner vers le framework spring afin de régler tous ces problèmes.</p>
    </div>
</div>
</body>
</html>