<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1">
    <title>Spring</title>

    <link href="../../../common/css/css.css" rel="stylesheet" type="text/css">
    <link href="../../../common/css/prettify.css" rel="stylesheet" id="prettify-link">
    <link href="../../../common/css/default.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/dev.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/project.css" class="theme" rel="stylesheet">

    <script src="../../../common/js/prettify.js"></script>

</head>
<body onload="prettyPrint();">
<div class="presentation">
    <div id="project">
        <h1><img src="img/spring.png" alt="" style="margin-right:5px;height:40px;position: relative;top:6px;">Spring</h1>

        <h2>Introduction</h2>

        <p>Spring est un framework facilitant la création d'applications d'entreprise (jee).</p>

        <img src="img/container.png" alt="" style="margin: 0 200px;">

        <p>C'est un conteneur dans le conteneur jee.</p>

        <p>Les composants spring sont appelés <b>beans</b>.</p>

        <h2>L'injection de dépendances</h2>

        <p>Les relations entre les composants sont appelées dépendances.</p>

        <img src="img/class-diagram.png" alt="" style="margin: 0 140px;">

        <p>Ce réseau de dépendances est mis en place au démarrage de l'application.</p>

        <p>La mise en relation est appelée wiring (câblage) et c'est la spécialité de spring.</p>

        <p>Cela permet de se concentrer sur chaque objet en faisant abstraction d'une partie de la complexité.</p>

        <p>En conséquence, cela rend les composants plus simples et plus portables</p>

        <h2>Dépendances</h2>

        <p>Avant de commencer, nous allons rajouter les jars nécessaires à spring dans le pom.xml.</p>

        <pre class="prettyprint">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
  &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
  &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
  &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
  &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;javax.inject&lt;/groupId&gt;
  &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
&lt;/dependency&gt;</pre>

        <p>Et on peut faire un mvn eclipse:eclipse.</p>

        <h2>Mise en place du contexte spring</h2>

        <p>Nous mettons en place un contexte spring : c'est la définition l'ensemble des composants gérés par spring.</p>

        <p>Comme d'habitude, nous commencons par les tests.</p>

        <p>La première étape consiste à définir un fichier TaskServiceTest-context.xml dans le package fr.todooz.service dans le répertoire source des tests.</p>

        <pre class="prettyprint">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
   http://www.springframework.org/schema/beans
   classpath:org/springframework/beans/factory/xml/spring-beans-3.0.xsd" &gt;

&lt;/beans&gt;</pre>

        <p>Ce fichier est un context spring vide pour les tests de TaskServiceTest.</p>

        <p>C'est dans ce fichier que seront définis les beans pour les tests.</p>

        <p>Afin que les fichiers xml dans src/test/java fasse partie du build, nous ajoutons la configuration suivante dans le pom (voir <a href="http://maven.apache.org/pom.html#Resources" class="external" target="_blank">configuration des resources</a>) :</p>

        <pre class="prettyprint">&lt;build&gt;
    &lt;testResources&gt;
        &lt;testResource&gt;
            &lt;directory&gt;${basedir}/src/test/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/testResource&gt;
    &lt;/testResources&gt;

    ...
&lt;/build&gt;</pre>

        <p>Et dans le test unitaire, on rajoute les annotations suivantes :</p>

        <pre class="prettyprint"><b>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration</b>
public class TaskServiceTest {
   ...
}</pre>

        <p>L'annotation <b>@RunWith</b> indique à JUnit que les tests tournent avec le plugin SpringJUnit4ClassRunner.</p>

        <p>L'annotation <b>@ContextConfiguration</b> active le chargement du contexte spring.</p>

        <p>Si on relance les tests, on voit que le contexte spring est chargé mais cela ne perturbe pas son exécution.</p>

        <h2>AnnotationSessionFactoryBean</h2>

        <p>La première chose que nous allons faire est de définir notre session factory dans le contexte spring. Dans TaskServiceTest-context.xml</p>

        <pre class="prettyprint">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
   http://www.springframework.org/schema/beans
   classpath:org/springframework/beans/factory/xml/spring-beans-3.0.xsd" &gt;

<span class="comment">&lt;!-- factory bean pour la SessionFactory hibernate --&gt;</span>
<b>&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
   &lt;property name="hibernateProperties"&gt;
      &lt;bean class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
         &lt;property name="properties"&gt;
            &lt;props&gt;
               &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.DerbyDialect&lt;/prop&gt;
               &lt;prop key="hibernate.connection.url"&gt;jdbc:derby:target/testdb;create=true&lt;/prop&gt;
               &lt;prop key="hibernate.connection.driver_class"&gt;org.apache.derby.jdbc.EmbeddedDriver&lt;/prop&gt;
               &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt;
            &lt;/props&gt;
         &lt;/property&gt;
      &lt;/bean&gt;
   &lt;/property&gt;
   &lt;property name="packagesToScan" value="fr.todooz.domain"/&gt;
&lt;/bean&gt;</b>

&lt;/beans&gt;</pre>

        <p>C'est une configuration équivalente à ce que nous avions dans notre méthode createSessionFactory(). Nous pouvons donc supprimer cette méthode.</p>

        <pre class="prettyprint"><s>@Before
public void createSessionFactory() {
  Configuration configuration = new Configuration();

  configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.DerbyDialect");
  configuration.setProperty("hibernate.connection.url", "jdbc:derby:target/testdb;create=true");
  configuration.setProperty("hibernate.connection.driver_class", "org.apache.derby.jdbc.EmbeddedDriver");
  configuration.setProperty("hibernate.hbm2ddl.auto", "create-drop");

  configuration.addAnnotatedClass(Task.class);

  sessionFactory = configuration.buildSessionFactory();
}</s></pre>

        <p>En échange, on injecte la session factory définie dans notre contexte de notre test.</p>

        <pre class="prettyprint"><b>@Inject</b>
private SessionFactory sessionFactory;</pre>

        <p>L'annotation <b>@Inject</b> permet de demander à spring d'injecter une dépendance dans notre composant.</p>

        <p>C'est l'activité de base du wiring : injecter les dépendances.</p>

        <p>Et nous n'avons plus besoin de fermer la SessionFactory nous même.</p>

        <pre class="prettyprint">@After
public void cleanDb() {
  Session session = sessionFactory.openSession();

  Transaction transaction = session.beginTransaction();

  session.createQuery("delete from Task").executeUpdate();

  transaction.commit();

  session.close();

  <s>sessionFactory.close();</s>
}</pre>

        <p>Du code java contre du xml, pour le moment nous n'avons pas encore gagné grand chose.</p>

        <p>Cependant, nous avons désormais clairement identifié le composant sessionFactory.</p>

        <p>Les tests unitaires devraient encore passer.</p>

        <h2>TaskService v1.1</h2>

        <p>Ensuite on ajoute notre service dans le contexte spring.</p>

        <pre class="prettyprint">&lt;bean class="fr.todooz.service.TaskService" /&gt;</pre>

        <p>Au démarrage du contexte spring, une instance de la classe TaskService sera donc instanciée.</p>

        <p>On profite du fait que notre bean soit géré par spring afin de supprimer la méthode setSessionFactory de notre PostService.</p>

        <pre class="prettyprint"><b>@Inject</b>
private SessionFactory sessionFactory;</pre>

        <p>Et dans le test unitaire, plus besoin d'instancier notre service nous même. On échange donc :</p>

        <pre class="prettyprint"><s>TaskService taskService = new TaskService();
taskService.setSessionFactory(sessionFactory);</s></pre>

        <p>contre</p>

        <pre class="prettyprint">@Inject
private TaskService taskService;</pre>

        <p>Les tests passent encore, on a gagné quelques lignes de code.</p>

        <h2>TaskService v2.0</h2>

        <p>Nous allons maintenant nous séparer de la gestion des fermetures de sessions (session.close()) et cela fonctionnera même en cas d'erreur.</p>

        <p>En bonus, nous allons rendre tout notre code transactionnel dans le même temps.</p>

        <p>En premier, nous devons extraire une interface à partir de notre service.</p>

        <p>C'est une contrainte lié au langage java qui ne peut générer des <a href="http://en.wikipedia.org/wiki/Proxy_pattern" class="external" target="_blank">proxies</a> qu'a partir d'une interface.</p>

        <p>Heureusement, eclipse va nous aider un peu.</p>

        <p>Dans elipse, on fait un rename de la classe TaskService vers TaskServiceImpl (clic droit sur la classe).</p>

        <img src="img/rename.png" style="margin:0 80px;" />

        <p>Puis on extrait une interface TaskService à partir de notre classe (clic droit sur la classe).</p>

        <img src="img/extract-interface.png" style="margin:0 65px;" />

        <p>Il faut sélectionner les 5 méthodes et ne pas prendre l'option "Declare interface methods as 'abstract'".</p>

        <p>Ne reste qu'à changer la définition du bean à instancier dans le contexte.</p>

        <pre class="prettyprint">&lt;bean class="fr.todooz.service.TaskServiceImpl" /&gt;</pre>

        <p>En effet TaskService est maintenant une interface, donc on ne peut pas l'instancier.</p>

        <p>Une interface plus tard, les tests passent toujours.</p>

        <p>Maintenant on ajoute une annotation <b>@Transactional</b> sur les 5 méthodes de l'implémentation et on peut retirer toute la gestion de la fermeture de la session.</p>

        <p>Par exemple, la méthode save devient :</p>

        <pre class="prettyprint">@Override
@Transactional
public void save(Task task) {
    Session session = sessionFactory.<b>getCurrentSession()</b>;

    session.save(task);
}</pre>

        <p>Cela simplifie grandement nos méthodes, nous libérant ainsi d'une partie répétitive et sujette à bugs.</p>

        <p>Pour que les tests unitaires passent il faut quand même rajouter un peu de configuration dans le fichier xml.</p>

        <pre class="prettyprint">&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	<b>xmlns:tx="http://www.springframework.org/schema/tx"</b>
	xsi:schemaLocation="
   http://www.springframework.org/schema/beans
   classpath:org/springframework/beans/factory/xml/spring-beans-3.0.xsd
   <b>http://www.springframework.org/schema/tx
   classpath:org/springframework/transaction/config/spring-tx-3.0.xsd"</b> &gt;

   ...

<span class="comment">&lt;!-- ajoute un gestionnaire de transactions lié à la sessionFactory --&gt;</span>
<b>&lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
&lt;/bean&gt;</b>

<span class="comment">&lt;!-- active le support des annotations @Transactional --&gt;</span>
<b>&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;</b>

   ...

&lt;/beans&gt;</pre>

        <p>C'est maintenant le contexte spring qui va gérer :</p>

        <ul>
            <li>L'ouverture et la fermeture des session (pas de connection leak)</li>
            <li>Les transactions SQL</li>
        </ul>

        <p>Si tout va bien, les test passent toujours.</p>

        <p>La mise en place de la configuration spring peut sembler un peu lourde par rapport au gain en lignes de code mais :</p>

        <ul>
            <li>la configuration est factorisée et le gain va donc croissant avec le l'augmentation du nombre de composants.</li>
            <li>Nos services sont "injectables" facilement afin de construire notre application.</li>
            <li>Le code ne conserve que la partie à forte valeur ajoutée.</li>
            <li>Notre code est maintenant transactionnel et peut participer simplement à des transactions englobants plusieurs service en même temps.</li>
            <li>La démarcation des transactions est déclarative et tout la gestion des ressources est prise en charge.</li>
            <li>Les appels à notre service dans le test sont les mêmes que les appels qui auront lieu en production.</li>
        </ul>

        <h2>readOnly = true</h2>

        <p>Il existe une petite optimisation possible lors de l'utilisation des annotations @Transactional.</p>

        <p>En effet, si la relation avec la base se fait en lecture seule, alors il vaut mieux l'indiquer via la notation :</p>

        <pre class="prettyprint">@Transactional(readOnly = true)</pre>

        <p>Cela indique à spring (et donc aussi à hibernate) qu'il n'y aura pas d'écriture en base à la fin des opérations sql. Certaines vérifications n'auront donc pas à être appliquées et donc on gagnera un peu en performance.</p>

        <p>Si on tente de marquer une méthode comme étant en read only alors que ce n'est pas le cas, on obtient une erreur.</p>

        <pre class="prettyprint">Caused by: ERROR 25502: An SQL data change is not permitted for a read-only connection, user or database.</pre>

        <h2>DataSource</h2>

        <p>Jusqu'a présent, nous avons utilisé le pool de connexion fourni par hibernate qui ne manque pas de nous le dire dans les logs :</p>

        <pre class="prettyprint">Using Hibernate built-in connection pool (not for production use!)</pre>

        <p>Un pool de connexion permet d'optimiser la gestion des connexions en prêtant un nombre fini de connexions à des demandeurs. Cela évite d'ouvrir et fermer des liaisons avec la base données, ce qui est assez couteux.</p>

        <p>On utilise le pool fourni par la fondation apache.</p>

        <pre class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>

        <p>On donc modifier la définition de la SessionFactory dans notre contexte spring.</p>

        <pre class="prettyprint"><span class="comment">&lt;!-- pool de connexion --&gt;</span>
&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="org.apache.derby.jdbc.EmbeddedDriver"/&gt;
    &lt;property name="url" value="jdbc:derby:target/testdb;create=true"/&gt;
    &lt;property name="username" value=""/&gt;
    &lt;property name="password" value=""/&gt;
&lt;/bean&gt;

<span class="comment">&lt;!-- factory bean pour la SessionFactory hibernate --&gt;</span>
&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
    <b>&lt;property name="dataSource" ref="dataSource" /&gt;</b>
    &lt;property name="hibernateProperties"&gt;
        &lt;bean class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
            &lt;property name="properties"&gt;
                &lt;props&gt;
                    &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.DerbyDialect&lt;/prop&gt;
                    &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt;
                &lt;/props&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="packagesToScan" value="fr.todooz.domain"/&gt;
&lt;/bean&gt;</pre>

        <p>Nous avons un pool qui supporte la production et Hibernate est content.</p>

        <p>De plus, nous n'avons pas eu a changer une seule ligne de notre test ou de notre service.</p>

        <h2>TagCloudService</h2>

        <p>Maintenant que coder un service est devenu plus simple, nous allons en coder un second : le TagCloudService</p>

        <p>Voici l'interface TagCloudService à placer dans le package fr.todooz.service :</p>

        <pre class="prettyprint">public interface TagCloudService {
   public TagCloud buildTagCloud();
}</pre>

        <p>Le but est donc de réaliser la classe TagCloudServiceImpl qui implémente se service.</p>

        <p>Comme d'habitude, on commence par écrire un test unitaire.</p>

        <pre class="prettyprint">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
public class TagCloudServiceTest {
   @Inject
   private SessionFactory sessionFactory;

   @Inject
   private TagCloudService tagCloudService;

   @After
   public void cleanDb() {
      Session session = sessionFactory.openSession();

      Transaction transaction = session.beginTransaction();

      session.createQuery("delete from Task").executeUpdate();

      transaction.commit();

      session.close();
   }

   @Test
   public void buildEmptyTagCloud() {
      TagCloud tagCloud = tagCloudService.buildTagCloud();

      Assert.assertEquals(0, tagCloud.size());
   }

   @Test
   public void buildTagCloud() {
      saveSomeTasks();

      <b>TagCloud tagCloud = tagCloudService.buildTagCloud();</b>

      Assert.assertEquals(5, tagCloud.size());
      Assert.assertTrue(tagCloud.contains("java"));
      Assert.assertTrue(tagCloud.contains("python"));
      Assert.assertTrue(tagCloud.contains("nodejs"));
   }

   private void saveSomeTasks() {
      Session session = sessionFactory.openSession();

      Transaction transaction = session.beginTransaction();

      session.save(buildTask("java,cobol"));
      session.save(buildTask("java,python"));
      session.save(buildTask("ruby,python"));
      session.save(buildTask("nodejs"));

      transaction.commit();

      session.close();
   }

   private Task buildTask(String tags) {
      Task task = new Task();

      task.setDate(new Date());
      task.setTitle("Read Effective Java");
      task.setText("Read Effective Java before it's too late");
      task.setTags(tags);

      return task;
   }
}</pre>

        <p>Définissez le contexte spring et codez la classe TagCloudServiceImpl afin que ce test passe.</p>

        <p>Voici quelques indices :</p>

        <ul>
            <li>TagCloudServiceImpl doit implémenter TagCloudService.</li>
            <li>Le service doit aller chercher tous les tags en base.</li>
            <li>Il est possible de faire un import d'un contexte dans un autre via un tag xml, par ex : <br>&lt;import resource="test-context.xml" /&gt;</li>
            <li>Utiliser la méthode org.apache.commons.lang.StringUtils.split afin de découper un String en un tableau de String.</li>
        </ul>
    </div>
</div>
</body>
</html>