<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1">
    <title>Hibernate</title>

    <link href="../../../common/css/css.css" rel="stylesheet" type="text/css">
    <link href="../../../common/css/prettify.css" rel="stylesheet" id="prettify-link">
    <link href="../../../common/css/default.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/dev.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/project.css" class="theme" rel="stylesheet">

    <script src="../../../common/js/prettify.js" onload="prettyPrint();"></script>

</head>
<body>
<div class="presentation">
    <div id="project">
        <h1><img src="img/hibernate.png" width="300px"></h1>

        <h2>Introduction</h2>

        <p>Hibernate est un framework de persitence objet - base de données relationnelles.</p>

        <p>Il implémente et étend JPA (Java Persitance API), le standard de persistence jee.</p>

        <img src="img/another-layer.png" alt="" style="margin: 0 250px;">
        
        <p>Techniquement, c'est une surcouche de JDBC qui en simplifie grandement l'usage.</p>

        <h2>Configuration hibernate</h2>

        <p>Comme pour la configuration de derby, nous allons écrire un test unitaire afin de mettre en place notre couche de persistance.</p>

        <p>Nous créons un test HibernateTest dans le package edu.ecm.blog.hibernate.</p>

        <pre>@Test
public void createSessionFactory() {
   Configuration configuration = new Configuration();

   configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.DerbyDialect");
   configuration.setProperty("hibernate.connection.url", "jdbc:derby:target/testdb;create=true");
   configuration.setProperty("hibernate.connection.driver_class", "org.apache.derby.jdbc.EmbeddedDriver");
   configuration.setProperty("hibernate.hbm2ddl.auto", "create-drop");

   SessionFactory sessionFactory = configuration.buildSessionFactory();
}</pre>

        <p>C'est l'équivalent de la création de la connexion en JDBC.</p>

        <p>Le guide complet de la <a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/session-configuration.html" class="external" target="_blank">configuration de hibernate</a></p>

        <p>Ce test ne passe que si on ajoute les entrées suivantes dans le pom.xml</p>

        <pre>&lt;dependency&gt;
  &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
  &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
  &lt;version&gt;3.6.4.Final&lt;/version&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;javassist&lt;/groupId&gt;
  &lt;artifactId&gt;javassist&lt;/artifactId&gt;
  &lt;version&gt;3.12.1.GA&lt;/version&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
  &lt;version&gt;1.6.1&lt;/version&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>

        <p>Ce test génère pas mal de traces dans la console au démarrage d'hibernate.</p>

        <p>La SessionFactory que l'on récupère est un wrapper autour des APIs JDBC.</p>

        <p>Elle permet de récupérer une Session qui est le pendant d'une Connection JDBC.</p>

        <h2>Les classes du domaine</h2>

        <p>Avant de pouvoir utliser concrètement notre SessionFactory, il faut lui donner la configuration des classes que l'on veut persiter.</p>

        <p>La façon la plus simple est de le faire via des annotations dans nos classes du domaine.</p>

        <p>On ajoute les annotations @Entity, @Table, @Column et @ManyToOne.</p>

        <pre>@Entity
@Table(name = "author")
public class Author {
   @Column
   private String name;

   @Column
   private String email;

   ...
}</pre>

        <pre>@Entity
@Table(name = "post")
public class Post {
   @Column
   private String title;
   
   @Column
   @Temporal(TemporalType.TIMESTAMP)
   private Date date;
   
   @Column
   private String slug;
   
   @ManyToOne(optional = true)
   private Author author;
   
   @Column(length = 4000)
   private String text;
   
   @Column
   private String tags;
 
   ...
}</pre>

        <p>Il est aussi possible de tout configurer (hibernate et objets du domaine) via fichiers xml mais cela est beaucoup plus verbeux.</p>

        <p>Il ne reste qu'à informer hibernate de la présence de nos beans annotés.</p>

        <pre>configuration.addAnnotatedClass(Author.class);
configuration.addAnnotatedClass(Post.class);</pre>

        <p>Une exécution en l'état nous indique que :</p>

        <pre>org.hibernate.AnnotationException: No identifier specified for entity: edu.ecm.blog.domain.Author
   at org.hibernate.cfg.InheritanceState.determineDefaultAccessType(InheritanceState.java:268)
   at org.hibernate.cfg.InheritanceState.getElementsToProcess(InheritanceState.java:223)
   at org.hibernate.cfg.AnnotationBinder.bindClass(AnnotationBinder.java:686)
   at org.hibernate.cfg.Configuration$MetadataSourceQueue.processAnnotatedClassesQueue(Configuration.java:4035)
   at org.hibernate.cfg.Configuration$MetadataSourceQueue.processMetadata(Configuration.java:3989)
   at org.hibernate.cfg.Configuration.secondPassCompile(Configuration.java:1398)
   at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1856)
   at edu.ecm.blog.hibernate.HibernateTest.createSessionFactory(HibernateTest.java:23)
   at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
   at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
   at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
   at java.lang.reflect.Method.invoke(Method.java:597)
   at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
   at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
   at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
   at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
   at org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)
   at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)
   at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)
   at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
   at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
   at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
   at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
   at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
   at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
   at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:49)
   at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
   at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
   at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
   at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
   at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)</pre>

        <p>Pour corriger cette erreur, il suffit de rajouter un identifiant unique dans chaque classe.</p>

        <pre>@Id
@GeneratedValue(strategy = GenerationType.AUTO)
private Long id;

public Long getId() {
  return id;
}

public void setId(Long id) {
  this.id = id;
}</pre>

        <p>Cet identifiant servira de clé primaire dans la base de données.</p>

        <p>Il utilise une stratégie de génération automatique : hibernate demandera à la base de générer des identifiants quand il en aura besoin.</p>

        <p>Désormais, ce test unitaire passe.</p>

        <h2>Persister un objet</h2>

        <p>Afin de voir ce que peut faire hibernate, nous allons persister un Author. On ajoute le test suivant.</p>

        <pre>@Test
public void saveAuthor() {
    Author author = new Author();

    author.setName("Harpo Marx");
    author.setEmail("harpo.marx@gmail.com");

    Session session = sessionFactory.openSession();

    session.save(author);

    session.close();
}</pre>

        <p>Afin de pouvoir écrire ce test il faut avoir passé le test précédent (createSessionFactory) en @Before au lieu de @Test afin d'initialiser la SessionFactory.</p>

        <p>Hibernate nous permet donc de sauver un objet dans une table sans que nous ayons à manipuler de SQL.</p>

        <p>De même que pour les tests jdbc, nous ne fermons pas correctement notre Session si jamais une erreur survient.</p>

        <p>Comme nous somme dans du code de test, cela est suffisant pour le moment.</p>

        <p>Malgré cela, nous devons quand même bien nettoyer la base après notre test et fermer la SessionFactory.</p>

        <pre>@After
public void cleanDb() {
    Session session = sessionFactory.openSession();

    Transaction transaction = session.beginTransaction();

    session.createQuery("<b>delete from Author</b>").executeUpdate();

    transaction.commit();

    session.close();

    sessionFactory.close();
}</pre>

        <p>La transaction ici permet à hibernate de bien valider la modification en base pour cette opération dite "bulk" (en masse).</p>

        <h2>Rechercher un objet</h2>

        <p>Rechercher un objet dans la base se fait tout aussi simplement que la persistence.</p>

        <p>Pour les requêtes, hibernate utilise un language proche du SQL : le <a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/queryhql.html" class="external" target="_blank">HQL</a> (Hibernate Query Language).</p>

        <p>Le HQL permet de travailler avec le nom des attributs des classes au lieu du nom des colonnes en base.</p>

        <pre>@Test
public void findAuthor() {
    saveAuthor();

    Session session = sessionFactory.openSession();

    Query query = session.createQuery("<b>from Author where name = :name</b>");

    query.setString("name", "Harpo Marx");

    List&lt;Author&gt; authors = query.list();

    session.close();

    Assert.assertEquals(1, authors.size());
    Assert.assertEquals("Harpo Marx", authors.get(0).getName());
}</pre>

        <p>Avec hibernate on récupère directement nos objets à partir de la base (au lieu d'un ResultSet).</p>

        <p>En plus du HQL, il existe une autre API encore plus orientée objet : la <a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/querycriteria.html" class="external" target="_blank">Criteria API</a></p>

        <pre>@Test
public void findAuthorCriteria() {
    saveAuthor();

    Session session = sessionFactory.openSession();

    Criteria criteria = session.createCriteria(<b>Author.class</b>);

    criteria.add(Restrictions.eq("name", "Harpo Marx"));

    List&lt;Author&gt; authors = criteria.list();

    session.close();

    Assert.assertEquals(1, authors.size());
    Assert.assertEquals("Harpo Marx", authors.get(0).getName());
}</pre>

        <p>Ces 2 APIs sont disponibles en fonction du besoin.</p>

        <h2>PostService</h2>

        <p>Avec hibernate nous allons pouvoir écrire simplement notre service de gestion de billets.</p>

        <p>Les opérations à supporter sont :</p>

        <ul>
            <li>save(post) : persister un billet en base</li>
            <li>delete(id) : supprimer un billet</li>
            <li>find(pageIndex, pageSize) : charger une liste de billets</li>
            <li>count() : le nombre total de billets en base</li>
        </ul>

        <p>On crée donc la classe PostService dans edu.ecm.blog.service.</p>

        <pre>public class PostService {
   public void save(Post post) {
      <span class="comment">// TODO</span>
   }

   public void delete(Long id) {
      <span class="comment">// TODO</span>
   }

   public List&lt;Post&gt; find(int pageIndex, int pageSize) {
      <span class="comment">// TODO</span>
   }

   public int count() {
      <span class="comment">// TODO</span>
   }
}</pre>

        <p>Afin d'implémenter ces méthodes, nous allons utiliser une classe de test, PostServiceTest, dans le package edu.ecm.blog.service du répertoire src/test/java.</p>

        <pre>public class PostServiceTest {
   private SessionFactory sessionFactory;

   @Before
   public void createSessionFactory() {
      Configuration configuration = new Configuration();

      configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.DerbyDialect");
      configuration.setProperty("hibernate.connection.url", "jdbc:derby:target/testdb;create=true");
      configuration.setProperty("hibernate.connection.driver_class", "org.apache.derby.jdbc.EmbeddedDriver");
      configuration.setProperty("hibernate.hbm2ddl.auto", "create-drop");

      configuration.addAnnotatedClass(Author.class);
      configuration.addAnnotatedClass(Post.class);

      sessionFactory = configuration.buildSessionFactory();
   }

   @After
   public void cleanDb() {
      Session session = sessionFactory.openSession();

      Transaction transaction = session.beginTransaction();

      session.createQuery("delete from Post").executeUpdate();

      transaction.commit();

      session.close();

      sessionFactory.close();
   }

   @Test
   public void save() {

   }
}</pre>

        <p>Et nous commençons par la méthode save. Nous souhaiterions pouvoir écrire :</p>

        <pre>@Test
public void save() {
    PostService postService = new PostService();
    postService.setSessionFactory(sessionFactory);

    Post post = new Post();
    post.setTitle("un post");
    post.setDate(new Date());

    postService.save(post);
}</pre>

        <p>Faites en sorte que cela soit possible et que ce test passe en prenant soin de bien fermer la session.</p>

        <p>Le delete (<a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/queryhql.html#queryhql-bulk" class="external" target="_blank">doc hibernate</a>).</p>

        <pre>@Test
public void delete() {
    PostService postService = new PostService();
    postService.setSessionFactory(sessionFactory);

    Post post = new Post();
    post.setTitle("un post");
    post.setDate(new Date());

    postService.save(post);

    postService.delete(post.getId());

    Session session = sessionFactory.openSession();

    Assert.assertEquals(0, session.createQuery("from Post").list().size());

    session.close();
}</pre>

        <p>Le find avec la <a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/querycriteria.html" class="external" target="_blank">criteria API</a></p>

        <pre>@Test
public void find() {
    PostService postService = new PostService();
    postService.setSessionFactory(sessionFactory);

    Post post = new Post();
    post.setTitle("un post");
    post.setDate(new Date());

    postService.save(post);

    post = new Post();
    post.setTitle("un post");
    post.setDate(new Date());

    postService.save(post);

    Assert.assertEquals(2, postService.find(0, 10).size());
    Assert.assertEquals(1, postService.find(0, 1).size());
    Assert.assertEquals(0, postService.find(1, 10).size());
}</pre>

        <p>Et le count</p>

        <pre>@Test
public void count() {
    PostService postService = new PostService();
    postService.setSessionFactory(sessionFactory);

    Post post = new Post();
    post.setTitle("un post");
    post.setDate(new Date());

    postService.save(post);

    post = new Post();
    post.setTitle("un post");
    post.setDate(new Date());

    postService.save(post);

    Assert.assertEquals(2, postService.count());
}</pre>

        <p>Après ce test, notre service est donc suffisament opérationnel pour le moment.</p>

        <p>Cependant, nous avons beaucoup de duplication de code dans nos tests unitaires et le code reste assez verbeux.</p>

        <p>Sans casser les tests, il serait possible de grandement simplifier ce code.</p>

        <h2>Les limites</h2>

        <p>Tout ce que nous avons écrit aurait été très verbeux en SQL.</p>

        <p>Hibernate est une aide précieuse lorsque l'on travaille avec des objets et une base de données relationelles.</p>

        <p>Mais notre code a encore quelques limitations :</p>

        <ul>
            <li>Gestion des ouvertures et fermetures de sessions à la main.</li>
            <li>Il faut fournir la SessionFactory au service.</li>
            <li>Pas de gestion de transaction.</li>
            <li>Nous n'utilisons pas de pool de connexion sérieux (hibernate fournit un pool par défaut suffisant pour les tests).</li>
            <li>La mise en place de la SessionFactory n'est pas facilement factorisable.</li>
        </ul>

        <p>Avant de coder un second service, nous allons nous tourner vers le framework spring afin de régler tous ces problèmes.</p>
    </div>
</div>
</body>
</html>