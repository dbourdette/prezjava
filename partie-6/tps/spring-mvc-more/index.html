<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1">
    <title>Spring MVC Mappings</title>

    <link href="../../../common/css/css.css" rel="stylesheet" type="text/css">
    <link href="../../../common/css/prettify.css" rel="stylesheet" id="prettify-link">
    <link href="../../../common/css/default.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/dev.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/project.css" class="theme" rel="stylesheet">

    <script src="../../../common/js/prettify.js"></script>

</head>
<body onload="prettyPrint();">
<div class="presentation">
    <div id="project">
        <h1><img src="img/spring.png" alt="" style="margin-right:5px;height:40px;position: relative;top:6px;">Spring MVC mappings</h1>

        <p>Nous allons ajouter quelques méthodes afin de pouvoir naviguer un peu plus dans nos billets.</p>

        <p>L'interface html nous propose 3 entrées que nous allons implémenter :</p>

        <ul>
            <li>Le moteur de recherche dans le header</li>
            <li>La navigation par tags</li>
            <li>La naviagtion par date</li>
        </ul>

        <h2>La recherche</h2>

        <p>Notre service propose déjà une méthode pour faire de la recheche.</p>

        <pre class="prettyprint">public List&lt;Task&gt; findByQuery(String query);</pre>

        <p>Nous pouvons donc l'utiliser afin de proposer simplement le mapping suivant dans notre Controller</p>

        <pre class="prettyprint">@RequestMapping("/search")
public String search(String query, Model model) {
    <span class="comment">...</span>
}</pre>

        <p>Le paramètre query de la méthode correspond à un paramètre de la requête GET http.</p>

        <p>Configurer le formulaire du header afin qu'il aboutisse sur cette méthode.</p>

        <p>Faire l'implémentation de cette méthode.</p>

        <h2>Le filtre par tag</h2>

        <p>La colonne de droite contient un tag cloud.</p>

        <p>Les liens sur les tags sont de la forme /tag/{tag}.</p>

        <p>Le mapping dans le controller peut s'écrire comme suit :</p>

        <pre>@RequestMapping("/tag/{tag}")
public String tag(@PathVariable String tag, Model model) {
    <span class="comment">...</span>
}</pre>

        <div class="note">@PathVariable permet d'extraire une variable depuis le path</div>

        <p>Il reste donc à :</p>

        <ul>
            <li>Ajouter le tag cloud dans le model</li>
            <li>Formatter le tag cloud à partir des données fournies par le controller</li>
            <li>Ajouter la méthode utile findByTag dans le service</li>
            <li>Implémenter la méthode du controller</li>
        </ul>

        <p>On peut rajouter la méthode suivante dans le tag cloud</p>

        <pre class="prettyprint">public List&lt;String&gt; getTags() {
    return tags;
}</pre>

        <p>Afin de pouvoir écrire le c:forEach du tag cloud.</p>

        <div class="note">
            La feuille de style css/bootstrap.min.css est en relatif et le mapping /tag/{tag} est un cran plus bas dans l'arborescence.
            <br>
            Il est donc nécessaire (et généralement préférable) d'utiliser une uri absolue : /css/bootstrap.min.css
        </div>

        <h3>Le filtre par intervalle</h3>

        <p>En colonne de droite, il reste 2 liens qui ont pour but de filtrer par intervalle.</p>

        <pre class="prettyprint">&lt;ul&gt;
    &lt;li&gt;&lt;a href="/today"&gt;Today's&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/tomorrow"&gt;Tomorrow's&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</pre>

        <p>Implémenter tout ce qu'il faut afin que ces 2 liens fonctionnent.</p>

        <p>Pour manipuler des dates et des intervalles en java, le mieux est d'utiliser <a href="http://joda-time.sourceforge.net/" class="external">joda time</a> (artefact joda-time sur le <a href="http://search.maven.org" class="external">repository central</a>)</p>

        <p>Par exemple, pour aujourd'hui :</p>

        <pre class="prettyprint">private Interval todayInterval() {
    DateMidnight today = new DateMidnight();

    return new Interval(today, today.plusDays(1));
}</pre>

        <div class="note">new DateMidnight() est aujourd'hui a 00h00</div>

        <p>Coté service, il existe une Restrictions.between afin de construire la requête.</p>

        <h3>@ModelAttribute</h3>

        <p>Normalement, le code de notre controller ressemble au code suivant :</p>

        <pre class="prettyprint">@RequestMapping({ "/", "/index" })
public String index(Model model) {
    model.addAttribute("tagCloud", tagCloudService.buildTagCloud());

    ...
}

@RequestMapping("/search")
public String search(String query, Model model) {
    model.addAttribute("tagCloud", tagCloudService.buildTagCloud());

    ...
}

@RequestMapping("/tag/{tag}")
public String tag(@PathVariable String tag, Model model) {
    model.addAttribute("tagCloud", tagCloudService.buildTagCloud());

    ...
}

...</pre>

        <p>Pour ce genre duplication, spring MVC propose la factorisation suivante :</p>

        <pre class="prettyprint">@ModelAttribute
public TagCloud tagCloud() {
    return tagCloudService.buildTagCloud();
}</pre>

        <p>Ainsi un attribut tagCloud va être ajouté au modèle quelle que soit la méthode appelée.</p>

        <p>Suite à l'ajout de cette méthode, il faut supprimer tous les appels inutiles.</p>

        <h3>Et ?</h3>

        <p>Y a t il un autre duplication / optimisation que l'on peut proposer pour notre controller ?</p>


    </div>
</div>
</body>
</html>