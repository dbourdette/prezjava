<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1">
    <title>Spring MVC</title>

    <link href="../../../common/css/css.css" rel="stylesheet" type="text/css">
    <link href="../../../common/css/prettify.css" rel="stylesheet" id="prettify-link">
    <link href="../../../common/css/default.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/dev.css" class="theme" rel="stylesheet">
    <link href="../../../common/css/project.css" class="theme" rel="stylesheet">

    <script src="../../../common/js/prettify.js"></script>

</head>
<body onload="prettyPrint();">
<div class="presentation">
    <div id="project">
        <h1><img src="img/spring.png" alt="" style="margin-right:5px;height:40px;position: relative;top:6px;">Spring MVC</h1>

        <p>Les conteneurs de servlets sont des outils très puissants et très ouverts.</p>
        
        <p>Mais il ne serait pas pratique de construire une application riche avec des servlets.</p>

        <img src="img/container.png" alt="" style="margin: 0 150px;">

        <p>Les frameworks MVC pour le web apportent la facilité manquante.</p>

        <p>Nous allons travailler avec spring MVC, le module MVC du framework spring.</p>

        <h2>Mise en place</h2>

        <p>En premier, on rajoute les librairies pour spring mvc.</p>

        <pre class="prettyprint">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
    &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
   &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>

        <p>Dans le web.xml, on rajoute la servlet spring. Elle reçoit toutes les requêtes.</p>
        
        <pre class="prettyprint">
<span class="comment">&lt;!-- Spring servlet --&gt;</span>
&lt;servlet&gt;
   &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
   &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
   &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
   &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
   &lt;url-pattern&gt;<b>/</b>&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre>

        <p>On supprime toutes les autres servlets au passage.</p>

        <p>Au démarrage de tomcat, cette servlet va aller charger un contexte spring (/WEB-INF/spring-servlet.xml) qu'il nous faut définir.</p>

        <pre class="prettyprint">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:context="http://www.springframework.org/schema/context"
   xmlns:mvc="http://www.springframework.org/schema/mvc"
   xmlns:tx="http://www.springframework.org/schema/tx"
   xmlns:p="http://www.springframework.org/schema/p"
   xmlns:aop="http://www.springframework.org/schema/aop"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;

   &lt;!-- Support des annotations --&gt;
   &lt;context:annotation-config /&gt;
   
   &lt;!-- Création de composants classiques pour spring mvc --&gt;
   &lt;mvc:annotation-driven /&gt;
   
   &lt;!-- Forwarde les demandes de fichiers statiques vers la servlet par défaut du conteneur --&gt;
   &lt;mvc:default-servlet-handler /&gt;

   &lt;!-- Définition de la Locale pour les opération de formattage --&gt;
   &lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.FixedLocaleResolver"&gt;
       &lt;property name="defaultLocale" value="fr_FR" /&gt;
   &lt;/bean&gt;

   &lt;!-- Configuration de la technologie de rendu  --&gt;
   &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt;
       &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt;
       &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;
       &lt;property name="suffix" value=".jsp" /&gt;
   &lt;/bean&gt;

&lt;/beans&gt;</pre>

        <p>Il est temps de rajouter notre premier Controller.</p>

        <h2>IndexController</h2>

        <p>Nous allons remplacer notre IndexServlet par la classe IndexController du package fr.todooz.web.controller.</p>

        <pre class="prettyprint">@Controller
public class IndexController {
   @RequestMapping("/index.html")
   public String index(Model model) {
      model.addAttribute("tasks", DummyData.tasks());
      
      return "index";
   }
}</pre>

        <p>L'annotation @Controller indique a spring qu'il s'agit d'un composant spécial qui répond aux requêtes http.</p>

        <p>L'annotation @RequestMapping fait la liaison entre une url et la méthode cible de la classe.</p>

        <p>Le Model est ce qui est rempli par le Controller et transmis à la vue (jsp).</p>

        <p>Le retour "index" va être mappé pas le viewResolver (avec le prefix et suffix de la configuration spring) et interpreté comme /WEB-INF/jsp/index.jsp.</p>

        <p>La création d'un Controller est une opération simple et les annotations apportent de la souplesse.</p>

        <p>Afin que ce composant soit chargé, il faut le définir dans le contexte spring.</p>

        <p>Comme nous allons faire plusieurs Controller, nous utilisons un scan de package dans spring-servlet.xml.</p>

        <pre class="prettyprint">&lt;!-- Découverte des contrôleurs --&gt;
&lt;context:component-scan base-package="fr.todooz.web.controller" /&gt;</pre>

        <p>Le Controller devrait répondre sur <a href="http://localhost:8080/index.html" target="_blank">http://localhost:8080/index.html</a> en lançant l'application avec la commande mvn tomcat:run.</p>

        <p>Afin d'avoir un contrôleur qui réponde à la racine de notre application, on change le mapping.</p>

        <pre class="prettyprint">@RequestMapping({"/", "/index"})</pre>

        <p>Maintenant, <a href="http://localhost:8080/" target="_blank">http://localhost:8080/</a>, <a href="http://localhost:8080/index" target="_blank">http://localhost:8080/index</a> et <a href="http://localhost:8080/index.html" target="_blank">http://localhost:8080/index.html</a> répondent.</p>

        <h2>Les services</h2>

        <p>Nous allons maintenant ajouter nos services dans le contexte spring afin de les rendre accessibles depuis les Controllers.</p>

        <p>Comme pour les Controllers, nous allons utiliser un scan.</p>

        <pre class="prettyprint">&lt;!-- Découverte des services --&gt;
&lt;context:component-scan base-package="fr.todooz.service"/&gt;</pre>

        <p>Et les 2 implémentations des services doivent être annoté avec @Service</p>

        <pre class="prettyprint">@Service
public class TaskServiceImpl implements TaskService</pre>

        <p>Ainsi les services du package seront chargés dans le contexte spring au démarrage de l'application.</p>

        <p>Les services sont chargés mais cela produit une erreur car aucune session factory n'est présente dans notre contexte spring.</p>

        <h2>La base de données</h2>
        
        <p>Comme pour les tests unitaires, il manque la définition de la session factory et de la connexion à la base.</p>

        <p></p>

        <pre class="prettyprint">&lt;!-- pool de connexion --&gt;
&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="org.apache.derby.jdbc.EmbeddedDriver"/&gt;
    &lt;property name="url" value="jdbc:derby:target/<b>taskdb</b>;create=true"/&gt;
    &lt;property name="username" value=""/&gt;
    &lt;property name="password" value=""/&gt;
&lt;/bean&gt;

&lt;!-- factory bean pour la SessionFactory hibernate --&gt;
&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="hibernateProperties"&gt;
        &lt;bean class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
            &lt;property name="properties"&gt;
                &lt;props&gt;
                    &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.DerbyDialect&lt;/prop&gt;
                    &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt;
                &lt;/props&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="packagesToScan" value="fr.todooz.domain"/&gt;
&lt;/bean&gt;

&lt;!-- ajoute un gestionnaire de transactions lié à la sessionFactory --&gt;
&lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
&lt;/bean&gt;

&lt;!-- active le support des annotations @Transactional --&gt;
&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;</pre>

        <p>La configuration est quasi identique à la configuration des tests.</p>

        <p>Pour une application réelle, nous n'utiliserions pas une base embarquée.</p>

        <p>Nous utiliserions une url qui pointe vers la base comme par exemple : jdbc:mysql://host:3306/taskdb.</p>

        <h2>Bootstrap</h2>

        <p>Il est maintenant possible d'injecter un service dans le contrôleur et d'en profiter.</p>

        <pre class="prettyprint">@Controller
public class IndexController {
  @Inject
  private TaskService taskService;

  @RequestMapping({ "/", "/index" })
  public String index(Model model) {
    model.addAttribute("tasks", taskService.findAll());

    return "index";
  }
}</pre>

        <p>Désormais la page <a href="http://localhost:8080/" target="_blank">http://localhost:8080/</a> est un peu vide mais elle utilise bien le service.</p>

        <p>En l'état, l'application démarre sans erreur mais les données sont toujours en dur dans la page jsp.</p>

        <p>On va donc remplir un peu la base au démarrage de l'application en attendant d'avoir le formulaire d'édition.</p>

        <p>Dans la classe IndexController on rajoute une méthode bootstrap</p>

        <pre class="prettyprint">@PostConstruct
public void bootstrap() {

}</pre>

        <p>@PostConstruct est une annotation java standard qui marque une méthode a appeler après la construction du composant.</p>

        <p>L'appel est fait après injection des dépendances.</p>

        <p>L'alter ego de @PostConstruct est @PreDestroy, appelé juste avant la destruction du composant.</p>

        <p>En utilisant le TaskService, implémenter le pseudo code suivant :</p>

        <pre class="prettyprint">if (pas de tâche) {
    créer 3 tâches différentes
}</pre>

        <p>En jouant un peu avec les cette méthode, il est possible d'avoir un peu de richesse sur la page de home.</p>

    </div>
</div>
</body>
</html>